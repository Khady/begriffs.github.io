---
title: Faster, Safer ActiveRecord
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
ActiveRecord ("AR") was introduced to abbreviate single-table <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> and basic inner joins. However, if used naively in bigger queries it can generate grossly inefficient SQL. This article will explore tricks for keeping AR fast when using moderately complex queries.<br /><br />For the full code behind this article, see my repository <a href="https://github.com/begriffs/orm-wars">ORM-wars</a>. Feel free to add your own AR tricks; pull requests are welcome.<br /><br /><h2>Strengthening constraints</h2>Consider a scenario with two models, User and Group where groups have many users. We'll create migrations for the tables, and establish the association between the models.<br /><br />Migration: <br /><pre><code>class CreateGroups &lt; ActiveRecord::Migration<br />  def self.up<br />    create_table :groups<br />  end<br /><br />  def self.down<br />    drop_table :groups<br />  end<br />end<br /><br />class CreateUsers &lt; ActiveRecord::Migration<br />  def self.up<br />    create_table :users<br />    add_column :users, :group_id, :integer<br />  end<br /><br />  def self.down<br />    drop_table :users<br />  end<br />end<br /></code></pre>Models: <br /><pre><code>class User &lt; ActiveRecord::Base<br />  belongs_to :group<br />end<br />class Group &lt; ActiveRecord::Base<br />  has_many :users<br />end<br /></code></pre>Notice how the association is (not) enforced. A pervasive opinion in AR is that database constraints should be enforced by Ruby code, not by the database. The belongs_to and has_many options do not affect the SQL that AR generates:<br /><pre>==  CreateUsers: migrating ====================================================<br />-- create_table(:users)<br />   (3.2ms)  CREATE TABLE "users" ("id" serial primary key) <br />   -&gt; 0.0039s<br />-- add_column(:users, :group_id, :integer)<br />   (0.3ms)  ALTER TABLE "users" ADD COLUMN "group_id" integer<br />   -&gt; 0.0009s<br />==  CreateUsers: migrated (0.0049s) ===========================================<br /></pre><br />This choice makes the database schema fragile. Data integrity is not guarded from other scripts or systems which may interact with the database. Without further precautions, the use of ActiveRecord encourages insular Ruby applications.<br /><br />Luckily there's a gem called <a href="https://github.com/matthuhiggins/foreigner/">foreigner</a> which makes AR serious about foreign key constraints. It defines the function <i>add_foreign_key</i> for migrations. We use it for our schema like so. <br /><pre><code>class CreateUsers &lt; ActiveRecord::Migration<br />  def self.up<br />    create_table :users<br />    add_column :users, :group_id, :integer<br />    add_foreign_key :users, :groups<br />  end<br /><br />  def self.down<br />    drop_table :users<br />  end<br />end<br /></code></pre>Validations at the Ruby model level are certainly helpful. They give form validators etc informative error messages. They are also useful when using a less capable database backend. However, when you are using a real database you would be wise to duplicate model validations as database constraints in your migrations. Postgres constraints, for instance, are <a href="http://www.postgresql.org/docs/9.0/static/ddl-constraints.html">not lacking</a>. This is most important if you plan to ever interact with your data outside of your Ruby app.<br /><br /><h2>Bulk imports</h2>Continuing the story, let's populate one hundred users and three groups, adding fifty users to one group, fifty to another, and none to the last. The default ActiveRecord behavior is inefficient. Each creation of a user or group issues a new command to the database, including a new transaction. Luckily there is a gem to help: <a href="https://github.com/zdennis/activerecord-import">activerecord-import</a>. It drastically improves the performance of bulk import. Just build arrays and import them:<br /><pre><code>Group.import [Group.new]*3<br />groups = Group.find(:all, :limit =&gt; 2)<br />User.import (0...100).map { |i| User.new(group: groups[i%2]) }<br /></code></pre><br /><h2>Using joins to avoid redundant queries</h2>Now that the database is seeded let's consider some queries and how to write them in ActiveRecord. First, how do we find which groups contain no users? The most obvious (but worst) way is to loop over the groups in Ruby and filter based on subsequent queries: <br /><pre><code>Group.all.select { |g| g.users.count == 0 }<br /></code></pre>However, ActiveRecord hides repeated queries behind its innocent fa√ßade. It ends up running a total of four queries: <br /><pre>Group Load (0.3ms)  SELECT "groups".* FROM "groups" <br />  (0.6ms)  SELECT COUNT(*) FROM "users" WHERE "users"."group_id" = 1<br />  (0.3ms)  SELECT COUNT(*) FROM "users" WHERE "users"."group_id" = 2<br />  (0.3ms)  SELECT COUNT(*) FROM "users" WHERE "users"."group_id" = 3<br /></pre>The bulk of the time in these small queries is simply spent sending them to the database. Consolidation is the best optimization.<br /><br />One way to do this is by thinking more relationally, and less in terms of objects. A left outer join can identify those groups with no users -- the user's group_id will be NULL. <br /><pre><code>Group.all(<br />  :joins =&gt; "LEFT OUTER JOIN users u ON u.group_id = groups.id",<br />  :conditions =&gt; "u.group_id IS NULL")<br /></code></pre>My benchmark shows this to be four times faster than the previous approach, exactly as expected. Not only is it a single query, but Postgres uses a scalable evaluation strategy: <br /><pre><code><br />------------------------------------------------------------------------------------<br /> Merge Anti Join  (cost=149.78..272.13 rows=1200 width=4)<br />   Merge Cond: (groups.id = u.group_id)<br />   -&gt;  Index Scan using groups_pkey on groups  (cost=0.00..84.25 rows=2400 width=4)<br />   -&gt;  Sort  (cost=149.78..155.13 rows=2140 width=4)<br />         Sort Key: u.group_id<br />         -&gt;  Seq Scan on users u  (cost=0.00..31.40 rows=2140 width=4)<br /></code></pre>However, we can still improve our query syntactically. ActiveRecord provides a more readable alternative to the longwinded join string<br /><pre><code>Group.includes(:users).where('users.group_id' =&gt; nil)<br /></code></pre>The <i>includes</i> method does so-called <a href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#label-Eager+loading+of+associations">eager loading</a>. Internally it uses a left outer join. Here is the SQL that ActiveRecord generates for this statement:<br /><pre><code>SELECT "groups"."id" AS t0_r0, "users"."id" AS t1_r0, "users"."group_id" AS t1_r1<br />FROM "groups" LEFT OUTER JOIN "users" ON "users"."group_id" = "groups"."id"<br />WHERE "users"."group_id" IS NULL<br /></code></pre>Essentially the same as the custom join, but with some unnecessary columns selected. The performance difference is negligible, so using the <i>includes</i> method is the best choice.<br /><br />Note that <i>includes</i> does not work with group-by clauses because it selects all columns, overriding previous choices of selection. So, for instance, to count how many users are in each group, we must use an explicit join: <br /><pre><code>Group.all(<br />    :select =&gt; "groups.id, count(u.group_id) as users_count",<br />    :joins  =&gt; "LEFT OUTER JOIN users u ON u.group_id = groups.id",<br />    :group  =&gt; "groups.id"<br />  )<br /></code></pre>
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/02872756980897311694">
  <div class="css-comment-name js-comment-name">
    Andrew
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2012-09-11T14:57:04.270Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Great post, Joe.<br /><br />Have you explored the bullet gem (http://github.com/flyerhzm/bullet)? It&#39;s an interesting development tool for identifying inefficient queries. There was a RailsCast about it just days after this post (http://railscasts.com/episodes/372-bullet).
  </div>
  <br/>
</div>
</div>
{% endraw %}
