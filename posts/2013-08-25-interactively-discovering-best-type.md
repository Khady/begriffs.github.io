---
title: Interactively discovering the best type classes for Haskell functions
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
Haskell's type classes exist to make make your functions more general while still keeping you safe. In this post I will work with GHC to arrive at the right signature for a function. The "weaker" the types we choose the more situations a function can handle. It's instructive to omit types entirely and see how GHC guides us toward the most general thing that can work. I see a parallel between trying to compile in a language like Haskell and running tests in a language like Ruby.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6332158"></code> <br />What does this function do, and what inputs are suitable? One way to approach the question is to use duck typing in a dynamic language. Just throw various values in and see if they quack. Write tests to handle a few cases and cross your fingers.<br /><br />How about asking the compiler which inputs work best? It can examine the type classes it knows and suggest a medley. Let's try to load this thing in GHC and see what it suggests.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6332346"></code> <br />It identifies the unknown functions "/", "..", "max" and "abs."&nbsp;What inputs would be appropriate for its arguments? Certainly something numeric. Yeah, we could choose <span style="font-family: Courier New, Courier, monospace;">Float -&gt; Float -&gt; [Float]</span>, but we don't want to be too specific and arbitrary. The language will hold us at our word. If it helps at all to think about the Haskell98 standard options you can examine the handy chart.<br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-oVjw7gqofDA/UhmeoVFIVOI/AAAAAAAAAEA/yi40kTrmlcU/s1600/classes.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="640" src="http://1.bp.blogspot.com/-oVjw7gqofDA/UhmeoVFIVOI/AAAAAAAAAEA/yi40kTrmlcU/s640/classes.gif" width="497" /></a></div><div class="separator" style="clear: both; text-align: left;">An arrow pointing from one box to another means that the target box can be used in all the situations that the source can.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">Based on the operations we used in our function the compiler suggests restricting the input to being an instance of Fractional, Enum, Ord and Num. This is a powerful way to think about how our function operates. It manipulates a value that can be sensibly divided, enumerated, ordered and acted upon with arithmetic. Let's add the restriction.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6332520"></code> <div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">But surely this is redundant! Some of these type classes include the others (in fact we know this is true by consulting the chart above). No need to speculate, just ask GHCi.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6332526"></code> <div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">OK, this is simplified a little bit. But you may ask why must we specify both Fractional and Ord? We learned to compare fractions as children. How can this stupid language standard not even consult grade-school math? Well, unlike some languages Haskell was not slapped together in a week in 1995 during a frenzied browser cashlust arms-race to turn a document presentation language into an interactive app platform.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">Nope, hearken back to 1927 when Emil Artin defined the concept of an <i>ordered field</i> in mathematics. This is a structure that a Haskeller could think of as Fractional + Ord. Of course the mathematical definition is all about the relationships of the various operations and the Haskell type classes do not enforce those axioms. But it's the intent of those classes, and Artin produced an example of a field which could not be ordered to suit the axioms: the complex numbers.</div><div class="separator" style="clear: both; text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: left;">In an ordered field the order interacts with the other operations in a way that people find pleasant and fertile with theorems. One property enforced is that if <i>a</i>, <i>b</i> &gt; 0 then <i>ab</i> &gt; 0 too. However in complex number<span style="font-family: Times, Times New Roman, serif;">s the element <i>i</i>&nbsp;<span style="background-color: white; line-height: 24px;">≠ 0. The order in an ordered field is <i>total </i>which means that in this case </span><span style="background-color: white; line-height: 24px;">either <i>i</i> &gt; 0 or <i>i</i> &lt; 0. Can't be the former since <i>i</i></span><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;">²</span><span style="background-color: white; line-height: 24px;">&nbsp;= -1 &lt; 0. And can't be the latter since (-<i>i</i>)</span><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;">² = -1 &lt; 0. And that's a problem.</span></span></div><div class="separator" style="clear: both; text-align: left;"><span style="font-family: Times, Times New Roman, serif;"><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;"><br /></span></span></div><div class="separator" style="clear: both; text-align: left;"><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;"><span style="font-family: Times, Times New Roman, serif;">So there you have it, that's why the Fractional class doesn't include the </span><span style="font-family: Courier New, Courier, monospace;">&lt;</span><span style="font-family: Times, Times New Roman, serif;"> operator. OK, fine, but why must we specify both Fractional and Enum? Can't we step through fractions one at a time from lower to higher? Well, depends on the order. In the usual ordering we use for fractions the answer is no. In math terms Enum would be called a well-ordering, because it means there is a single unique successor after each value. However no fraction has a "next" one, You can keep splitting finer and finer between any two fractions. Incidentally there are a few ways to well-order the rational numbers (fractions of integers) if you're willing to invent a weird order that doesn't play well with the other arithmetic operations. Georg Cantor discovered one way</span></span></div><div class="separator" style="clear: both; text-align: left;"><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;"><span style="font-family: Times, Times New Roman, serif;"><br /></span></span></div><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-9vRYM75Py-M/UhmzImxG2SI/AAAAAAAAAEQ/GKPO--b6XZY/s1600/Diagonale.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-9vRYM75Py-M/UhmzImxG2SI/AAAAAAAAAEQ/GKPO--b6XZY/s1600/Diagonale.jpg" /></a></div><div class="separator" style="clear: both; text-align: left;"><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;"><span style="font-family: Times, Times New Roman, serif;"><br /></span></span></div><div class="separator" style="clear: both; text-align: left;"><span style="background-color: #f9f9f9; color: #333333; line-height: 20px;"><span style="font-family: Times, Times New Roman, serif;">And that's why Fractional doesn't include a range-walking operator. Yeah, it's like the Haskell98 committee actually put some educated thought into what they were building.</span></span></div>
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/03097657129811885396">
  <div class="css-comment-name js-comment-name">
    Chris
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2013-08-26T01:57:55.495Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Ordering those pesky rational numbers keeps coming up. This was a really interesting post!
  </div>
  <br/>
</div>
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/16208489588423816254">
  <div class="css-comment-name js-comment-name">
    Manuel Gómez
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2013-09-11T05:51:08.563Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Excellent post!  Do make sure to avoid the `Enum` instances for `Float` and `Double` like the plague.  They allow for some cute sugar like `[0, 0.1 .. 1]`, but the details are somewhat unsound due to the imprecise nature of floating‐point values; their definition has made a lot of people very angry and has been widely regarded as a bad move.<br /><br />If you omit type signatures, Haskell will infer the most general type that applies to the definitions you give*.  There are even a few editor plugins here and there that will insert inferred signatures when you omit them.  If you get weird, unexpected type errors when omitting signatures for bindings you expect to be polymorphic, you’re probably running into the monomorphism restriction: a special rule in Haskell’s type inference mechanism that under some circumstances forces specific, monomorphic choices of types in value bindings that could normally be given a polymorphic type.  It’s usually better to avoid it altogether by using the NoMonomorphismRestriction and NoMonoLocalBinds LANGUAGE pragmas — but watch out for the very subtle performance implications of polymorphism!<br /><br />* as long as you don’t get too crazy with type system extensions — GADTs, Rank2Types, RankNTypes, ImpredicativeTypes and a few others don’t get along too well with type inference due to fundamental theoretical limitations.
  </div>
  <br/>
</div>
</div>
{% endraw %}
