---
title: Haskell postgresql-simple examples, part 1
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
I've been working on a simple api server, and getting confused by the sheer number of new Haskell things I need to learn. There are many combinations of http servers, frameworks, database libraries, and json parsing to try. So I'm taking a different route. I'm learning each piece in isolation so later I can put them together easily. Starting with database access.<br /><br />Let's take the magic out of talking to Postgres. How do you connect to an existing database and read/write data? The most direct way appears to be the <span style="font-family: Courier New, Courier, monospace;">postgresql-simple</span>&nbsp;package. There's an even lower level library called <span style="font-family: Courier New, Courier, monospace;">postgresql-libpq</span> that wraps the C-based libpq, but I don't relish the idea of managing a database connection and other low-level details.<br /><br />Can't get simpler than this: add two and two in sql. No table access needed.<br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6480346"></code> Some notes about this code. Notice how you can extend&nbsp;<span style="font-family: Courier New, Courier, monospace;">defaultConnectInfo</span>. It's more future-proof to do this than trying to specify an entire <span style="font-family: Courier New, Courier, monospace;">ConnectInfo</span> yourself. &nbsp;This is Haskell, after all, you can't just omit a field and the library might expect more fields in future versions. Extending the defaults will be fine because the new default will cover the new type.<br /><br />Also, other docs for this library show the use of <span style="font-family: Courier New, Courier, monospace;">query</span>, but you need <span style="font-family: Courier New, Courier, monospace;">query_</span> for queries which take no arguments. Speaking of docs in general, be careful what Google tells you. I was looking at the Hackage docs for version 0.1.5 of this library for a long time because that is what Google had indexed. The newest version as of this writing is 0.3.6! (Hackage should really display a glaring warning when you look at old versions of a package.)<br /><br /><hr /><b>Typing details and conventions -- safe to ignore.</b><br /><div><br /></div>The naming style of <span style="font-family: Courier New, Courier, monospace;">query_</span> flouts Haskell conventions where a trailing underscore means that the function suppresses a return type. For instance, we're using <span style="font-family: Courier New, Courier, monospace;">mapM_</span> in the code. Look how it differs from its scoreless brother<br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6505148"></code> <span style="font-family: Courier New, Courier, monospace;">MapM</span> is just map that burrows along through a monad. The <span style="font-family: Courier New, Courier, monospace;">print</span> function returns <span style="font-family: Courier New, Courier, monospace;">IO ()</span> and <span style="font-family: Courier New, Courier, monospace;">mapM_</span> is compatible with that. The <span style="font-family: Courier New, Courier, monospace;">query_</span> function returns <span style="font-family: Courier New, Courier, monospace;">IO</span> of a certain type of array, which is not compatible to be chained with <span style="font-family: Courier New, Courier, monospace;">print</span>s.<br /><hr /><br />On to the next query.<br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6504969"></code> What is this nasty&nbsp;<span style="font-family: Courier New, Courier, monospace;">IO [Only Int]</span> annotation? Might make you yearn for a looser language. It's an instance of a general Haskell principle. The less you <i>do</i> with a value, the more you have to describe its construction. All we're doing with our query results is looping through its rows (one row it turns out), and printing it. All print wants is an instance of Show. That's all the compiler can infer. The SQL string is kind of opaque. It's a foreign language to the compiler, so the compiler cannot see we are adding numbers.<br /><br />In fact here's another digression. SQL is like a foreign function interface isn't it? One based on string interpolation. If we instead built SQL expressions as Haskell datatypes then the compiler could know what we want. Hmm, I wonder what part two of this article will be about...<br /><br />So our annotation of <span style="font-family: Courier New, Courier, monospace;">IO</span> and <span style="font-family: Courier New, Courier, monospace;">Int</span> is clear. What about this <span style="font-family: Courier New, Courier, monospace;">Only</span> thing? It's some terminology created by <span style="font-family: Courier New, Courier, monospace;">postgresql-simple</span> to help protect you from injection. The <span style="font-family: Courier New, Courier, monospace;">query</span> function takes a final argument of type <span style="font-family: Courier New, Courier, monospace;">FromRow,</span>&nbsp;which is built out of <span style="font-family: Courier New, Courier, monospace;">FromField</span><span style="font-family: inherit;">s</span>. Specifically arrays, vectors, or tuples of <span style="font-family: Courier New, Courier, monospace;">FromField</span> -- or <span style="font-family: Courier New, Courier, monospace;">Only FromField</span> for a single one.<br /><br /><hr /><b>Digression.</b> In Haskell I don't think you can properly make recursive definitions with tuples. This library in particular allows you to make <span style="font-family: Courier New, Courier, monospace;">FromRow</span> on <span style="font-family: Courier New, Courier, monospace;">FromField</span> tuples of length two through ten. They actually specify the constructors for each of these eight sizes. Kind of crazy, isn't it? From what I can gather it's a flaw in Haskell's design that violates the <a href="https://en.wikipedia.org/wiki/Zero_one_infinity_rule">Zero, One, Infinity Rul</a>e and is remedied in Agda using dependent types. To construct bigger <span style="font-family: Courier New, Courier, monospace;">FromRow</span> tuples you can combine them with the library-defined <span style="font-family: Courier New, Courier, monospace;">(:.)</span> operator.<br /><hr /><br />So much for queries with and without arguments. How about commands? (This example assumes an existing table called <span style="font-family: Courier New, Courier, monospace;">words</span> with a column named <span style="font-family: Courier New, Courier, monospace;">word</span>.)<br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6505421"></code> Not much type annotation needed here, because the way we gather input tells the compiler what type it must be. Notice we use the <span style="font-family: Courier New, Courier, monospace;">execute</span> function now. I first tried <span style="font-family: Courier New, Courier, monospace;">query</span>, but it gives a runtime error when you try using destructive operations from <span style="font-family: Courier New, Courier, monospace;">query</span>. Another level of safety I guess.<br /><br />There you go, some pretty "normal" code for doing SQL. In part two we'll see a more streamlined way to interact with the database, and one that helps the compiler infer more and save you typing. But it's nice to see the non-magical way first, isn't it?
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/06136840792496025317">
  <div class="css-comment-name js-comment-name">
    Justin
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2013-09-11T08:32:45.748Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    I&#39;m not sure if you intend to try out more SQL wrappers, but I have a fond appreciation of Persistent, written by the Yesod Team (even though I do not use Yesod myself), and Esqeleto, which uses Persistent&#39;s types but offers a very expressive SQL interface.  Persistent is rather amazingly typed, and it carries that magical property of Haskell of &quot;If it compiles, it works.&quot; and &quot;debugging only exists at compile-time&quot;.<br /><br />One day I had a huge codebase and I decided to set one of the fields on a table to be nullable, and I was promptly told by ghc (by its refusal to compile) exactly where this may be a problem in every situation of my code.  In a dynamic language, or a less well-typed system, these are the types of errors that would otherwise only be caught at runtime or in production.
  </div>
  <br/>
</div>
</div>
{% endraw %}
