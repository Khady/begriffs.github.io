---
title: Tikhon Jelvis' ideas about Structural Merging
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
This afternoon I paired with Tikhon. He's a Haskeller, researcher, and the organizer of the SF Types, Theorems, and Programming Languages group. His&nbsp;<a href="https://github.com/TikhonJelvis/Cow">project</a> is to extend the unix commands <span style="font-family: Courier New, Courier, monospace;">diff</span> and <span style="font-family: Courier New, Courier, monospace;">merge</span> to understand and work better on JavaScript code.<br /><br />As a product of the Unix tradition the standard <span style="font-family: inherit;">diff</span> program operates line by line between files. This affects not just diff itself but programs like git that rely on it. Have you ever changed a program in a way that does not affect its operation such as changing indentation and then been forced to make a big git commit? Have you ever changed the name of a variable and caused a big fragmented commit? Tikhon believes that small changes of meaning should appear as small diffs and the reason that they currently don't is that we still think in terms of teletypes rather than syntax.<br /><br />Most importantly Tikhon realized that operating crudely on lines can create merge conflicts when there needn't be any. For instance, consider this original file:<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10095370"></code> One person edits it by moving one function inside the scope of the other.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10095432"></code> Another edits it by changing variable names.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10095463"></code> The merge fails! Resolution requires accepting one version and manually adding the changes from the other.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10095499"></code> His solution: a <i>structural</i>&nbsp;merge. A traditional diff sees each of these changes as many lines, whereas each of the files being merged differs by only a single structural change, and those changes can be harmlessly resolved. In terms of syntax, the first change (moving foo2 inside foo) looks like this<br /><div class="separator" style="clear: both; text-align: center;"><br /></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-Knis3bxVKk4/U0OU-6c6ZbI/AAAAAAAAAGo/LZrX9u5aSWY/s1600/Screen+Shot+2014-04-07+at+11.17.08+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-Knis3bxVKk4/U0OU-6c6ZbI/AAAAAAAAAGo/LZrX9u5aSWY/s1600/Screen+Shot+2014-04-07+at+11.17.08+PM.png" height="160" width="400" /></a></div><br />The second (renaming the variables) looks like this<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-RfZpgfMWGLs/U0OVQUSaGKI/AAAAAAAAAGw/QE8KhI56LKc/s1600/Screen+Shot+2014-04-07+at+11.20.23+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-RfZpgfMWGLs/U0OVQUSaGKI/AAAAAAAAAGw/QE8KhI56LKc/s1600/Screen+Shot+2014-04-07+at+11.20.23+PM.png" height="211" width="400" /></a></div>These representations are created using the Zhang-Shasha tree edit-distance algorithm. It indicates "tree diff" in terms of the node operations <i>move</i>, <i>relabel</i>, <i>add</i>, and <i>delete</i>. The algorithm finds the minimum number of applications of these rules to transform one tree into another.<br /><br />Interestingly if we create a tree diff of tree diffs themselves we can use it to display more meaningful merge conflicts. The diff of the two diff trees above looks like this<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-OIV9IvTVQkY/U0Oc15jMYLI/AAAAAAAAAHA/5DCmdROIC8k/s1600/Screen+Shot+2014-04-07+at+11.52.47+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/-OIV9IvTVQkY/U0Oc15jMYLI/AAAAAAAAAHA/5DCmdROIC8k/s1600/Screen+Shot+2014-04-07+at+11.52.47+PM.png" height="120" width="400" /></a></div>A second pass with a simplifying algorithm shows there is exactly one edit operation introduced by each change. A structural merge program can interactively ask the user which edit operation to apply (and can do them both if requested).<br /><br />Tikhon's big hurdle is to make his tree diff fast. As he quipped, "[it runs in] exponential time...I'm not a fan." The solution is dynamic programming, and in a lazy language like Haskell with immutable data structures it only takes a tiny change in a program to automatically memoize functions and enable dynamic programming. We spent the day investigating how to do it for his tree diff function, but began by playing with it in the simpler problem of string edit distance.<br /><br />Let me show you the trick first. It uses laziness and co-recursion to make the function and its lookup table always keep one step ahead of each other in a magical circle. Observe how it is used to generate Fibonacci numbers.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10098757"></code> Let's see a naive implementation of string edit distance and how to transform it with The Trick. It's a Haskell implementation of the&nbsp;Wagnerâ€“Fischer algorithm which recursively calculates the edit distance of every initial segment of the two strings eventually working up to the original strings. Using the edit operations insert, delete, and substitute it can be expressed succinctly as<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-nxQGb0WVeqU/U0OsTHTbgeI/AAAAAAAAAHQ/_eulKN864oo/s1600/Screen+Shot+2014-04-08+at+12.58.43+AM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-nxQGb0WVeqU/U0OsTHTbgeI/AAAAAAAAAHQ/_eulKN864oo/s1600/Screen+Shot+2014-04-08+at+12.58.43+AM.png" height="115" width="400" /></a></div><br />Translated to Haskell it becomes<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10100425"></code> The trick to make it fast is to co-recursively fill in a lookup table with the edit distances of initial segments, and to calculate edit distances...by referencing the table. Mind = blown.<br /><br />After implementing the function above that returns merely the minimum edit distance, we augmented it to return an array of the actual edit actions needed. Got into some performance problems of repeatedly calculating the length of those arrays when checking for the minimum, but found a way around that problem.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="10100821"></code> What remains is to translate this nice memoized string edit distance to trees using tree edit operations rather than string operations. Notice the lookup table we used above is a two-dimensional array indexed by the length of segments. To translate the lookup table strategy to trees we need a way to uniquely name partial-traversals, which we could do by choosing the number of hops along the traversal to be the "index." (We experimented with using a Haskell Map keyed off the trees but that was really slow.) Ultimately we did not complete the refactor to make the tree diff sub-exponential speed, but we discovered how it will be done.
</div>
{% endraw %}
