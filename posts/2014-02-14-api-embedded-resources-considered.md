---
title: API embedded resources considered harmful
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
<hr /><b>Update</b>: Another way to handle embedded resources is by including or excluding them explicitly with query parameters. For instance below we could pass a parameter like <span style="font-family: Courier New, Courier, monospace;">?include_cast=true</span> to the <span style="font-family: Courier New, Courier, monospace;">/movie</span> endpoint. It's possibly a more pragmatic way to customize the response.<br /><hr /><h3></h3><h3>The False Premise</h3><br />If you aren't familiar with resource embedding, it's where an API response contains related information that a client might want. An example would be to include cast information in a response about a movie:<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8994247"></code> We're taught that including embedded information saves the client from having to make additional HTTP requests. The only way to get more information is to make a fresh request, right?<br /><br />Not necessarily.&nbsp;For the past fifteen years the mainstream web development community has unfortunately neglected the HTTP spec. You see, by 1999 people had been using and learning from HTTP 1.0 for a few years. It had become obvious that the one-resource-per-request design was awkward. There is overhead to making web requests, from setting up TCP to querying DNS. When possible it makes sense to reuse an existing HTTP connection. Hence the HTTP 1.1 design committee invented the <i>keep-alive</i> header and <a href="https://en.wikipedia.org/wiki/HTTP_pipelining">HTTP pipelining</a>.<br /><br /><a href="http://1.bp.blogspot.com/-p2iSNmBl4uE/Uv3C1F5v4EI/AAAAAAAAAFA/KRZv7atKbFk/s1600/pipelining6requests.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://1.bp.blogspot.com/-p2iSNmBl4uE/Uv3C1F5v4EI/AAAAAAAAAFA/KRZv7atKbFk/s1600/pipelining6requests.png" height="320" width="222" /></a>With pipelining you load several requests into one connection. Sadly its support has been halting and incomplete because of subtleties about slow requests holding up later ones (the "head of line" problem). That subtlety means you shouldn't pipeline all assets by default. In a way browsers threw out the baby with the bathwater by not allowing you to pipeline selectively.<br /><br />Although we can't use real HTTP pipelining to put related requests together (at least not until <a href="http://tools.ietf.org/html/draft-ietf-httpbis-http2-10#section-5">HTTP/2</a>), there is another trick we can use, and it's a trick we can put into server middleware so it's transparent to our application code. But before getting into that, why bother?<br /><br /><h3>The Problems with Embedding</h3><div><br /></div><div>What are the downsides with embedding, anyway? It provides helpful information and anticipates the client's needs. If someone asks you to pass the salt, why not pass the pepper too?</div><div><br /></div><div>In the movie example the related cast information was no big deal. Pretty small. However in real requests this additional data can be large, and it's not always needed. Also including related data is a slippery slope. We could include reviews, showtimes, historical popularity, and similar movies. There's a limit to how much you choose to include.</div><div><br /></div><div>What some people tend to do is create multiple similar endpoints. In our example these endpoints might include a movie-with-its-reviews and a movie-with-cast. Even when developers don't intentionally start out designing the system this way its evolution often forces the design. Developers end up creating convenience endpoints to serve particular pages. After all, the app should be efficient!</div><div><br /></div><div>However it's not without problems. First, the backend gets harder to maintain. It accumulates similar controller actions with more tests and docs. Second, the chosen subsets are arbitrary. For \(n\) related datasets there are \(2^n\) possible embedded-subsets. So the client gets stuck with either more or less data than it needs. Third, independently limiting or filtering each embedded list is hard and might be implemented idiosyncratically and poorly in the app.</div><div><br /></div><h3>The Solution</h3><div><br /></div><div>The way to avoid these problems and keep the client and server light and flexible is through&nbsp;<i>relational batch requests</i>. Relational in the sense that we create self-contained root-level resources that accept query parameters to filter them appropriately. Batched in the sense that we combine requests for related resources into a single HTTP request -- a spontaneous request that the application code doesn't need to name or prepare for in any special way.</div><div><br /></div><div>If we have an identifier (in this example numerical) for a movie imagine we could send all these requests at once</div><div><br /></div><code br="" data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8996696" gt=""></code><br /><div>In fact you can, using a server middleware such as <a href="https://github.com/arsduo/batch_api">arsduo/batch_api</a> which replays the batched requests one by one locally on the server and combines the results. Your server code can't tell the difference. And each request is allowed to use unrestricted HTTP, with headers and params and all. I'll show you my idea for a clean Angular module to send the batch requests. But first let's consider a knee-jerk reaction to these kind of routes.<br /><br />Why are we routing to&nbsp;<span style="font-family: Courier New, Courier, monospace;">/cast?movie=12</span> rather than <span style="font-family: Courier New, Courier, monospace;">/movies/12/cast</span>? The former is not as conventional, at least in the Rails community. But remember this is an API. The endpoint URLs are not providing a visible sense of structure in a visitor's address bar. I don't see any benefits from nesting&nbsp;<span style="font-family: Courier New, Courier, monospace;">cast</span> under <span style="font-family: Courier New, Courier, monospace;">movies/:id</span>. All it does is make the queries less expressive. If you want a list of cast filtered in some other way you will need the root-level <span style="font-family: Courier New, Courier, monospace;">cast</span> route anyway, and now you have two routes to maintain.<br /><br /><blockquote class="tr_bq">Note that relational batch requests can't handle every kind of request efficiently. For instance aggregate queries should happen on the server. If you want the average rating of a movie it's overkill to request <span style="font-family: Courier New, Courier, monospace;">/reviews?movie=12</span> (even in parallel) and do the math when a fast backend database could do that. Unless someone develops a kind of "APIQL" like <span style="font-family: Courier New, Courier, monospace;">/reviews?movie=12&amp;select=avg(rating)</span>. Interesting, does anyone know of a library for this?</blockquote><br />To make it easy to consume batched APIs we could turn to Angular with its tools to abstract the traditional browser Javascript platform. One might write an extension of Angular's <span style="font-family: Courier New, Courier, monospace;">$resource</span> object that is built from other resources. The key is easy composition like this:<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8997749"></code> It could work by briefly registering an <span style="font-family: Courier New, Courier, monospace;">$http</span> request interceptor and running the quoted verb against each resource. The interceptor will sniff the urls and headers and save them to hidden variables. Then when <span style="font-family: Courier New, Courier, monospace;">execute()</span> is called on the batch it will make a request to the batch endpoint properly formatted for the batch middleware.<br /><br />Ultimately the client interface will be most pleasant if it is compositional. In other words if I can take regular resources and build more interesting things out of them recursively. There's nothing stopping a batch from containing other batches. Or containing a <a href="https://github.com/begriffs/angular-paginated-resource">paginated resource</a> rather than a plain one. Finally notice how in this approach the client is in charge of the format of the response. It can pull together any resources and assign them to arbitrary keys. I think with this approach we can create nimbler APIs that are fun to use and easy to maintain without sacrificing performance.</div>
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/11412131403812219889">
  <div class="css-comment-name js-comment-name">
    JN
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2014-02-14T20:29:22.129Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Should probably be `reviews: [&#39;query&#39;, $resource(&#39;/reviews?movie=:movieId&#39;, { ...`
  </div>
  <br/>
</div>
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/05440774752453573594">
  <div class="css-comment-name js-comment-name">
    Joe Nelson
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2014-02-14T20:33:02.926Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Thanks, fixed.
  </div>
  <br/>
</div>
</div>
{% endraw %}
