<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Creating sqlite tables with Groundhog's default settings</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap-readable.min.css" />
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  </head>
  <body>
    <div class="container">
      <div class="header row">
        <h3><a class="text-muted col-sm-6" href="../">begriffs</a></h3>

        <ul class="col-sm-6 list-inline">
          <li><a class="text-muted" href="../about.html">About</a></li>
          <li><a class="text-muted" href="http://github.com/begriffs"><i class="fa fa-github"></i></a></li>
          <li><a class="text-muted" href="http://twitter.com/begriffs"><i class="fa fa-twitter"></i></a></li>
        </ul>
      </div>

      <div class="post-header">
  <h3>Creating sqlite tables with Groundhog's default settings</h3>
  <a href="https://twitter.com/share" class="twitter-share-button pull-right" data-via="begriffs" data-count="none">Tweet</a>
  <h5 class="text-muted">August 31, 2013</h5>
</div>

<div class="content">
  <p>I simplified a Groundhog code example to see how it behaves with its default settings. To make this code work you’ll need to install some cabal packages.</p>
<pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cabal</span> install groundhog
<span class="kw">cabal</span> install groundhog-sqlite
<span class="kw">cabal</span> install groundhog-th</code></pre>
<p>Now for the code. We’ll declare tables for Machines and Parts, and create a relationship to say that machines have many parts. Then migrate out in-memory database, insert some sample data and query it.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs, TypeFamilies, TemplateHaskell, QuasiQuotes, FlexibleInstances, StandaloneDeriving #-}</span>
<span class="kw">import </span><span class="dt">Control.Monad.IO.Class</span> (liftIO)
<span class="kw">import </span><span class="dt">Database.Groundhog.TH</span>
<span class="kw">import </span><span class="dt">Database.Groundhog.Sqlite</span>

<span class="kw">data</span> <span class="dt">Machine</span> <span class="fu">=</span> <span class="dt">Machine</span> {<span class="ot"> modelName ::</span> <span class="dt">String</span>,<span class="ot"> cost ::</span> <span class="dt">Double</span> } <span class="kw">deriving</span> <span class="dt">Show</span>
<span class="kw">data</span> <span class="dt">Part</span> <span class="fu">=</span> <span class="dt">Part</span> {<span class="ot"> partName ::</span> <span class="dt">String</span>,<span class="ot"> weight ::</span> <span class="dt">Int</span>,<span class="ot"> machine ::</span> <span class="dt">DefaultKey</span> <span class="dt">Machine</span> }
<span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Part</span>

mkPersist defaultCodegenConfig [groundhog<span class="fu">|</span>
<span class="fu">-</span> entity<span class="fu">:</span> <span class="dt">Machine</span>
<span class="fu">-</span> entity<span class="fu">:</span> <span class="dt">Part</span>
<span class="fu">|</span>]

main <span class="fu">=</span> withSqliteConn <span class="st">&quot;:memory:&quot;</span> <span class="fu">$</span> runDbConn <span class="fu">$</span> <span class="kw">do</span>
  runMigration defaultMigrationLogger <span class="fu">$</span> <span class="kw">do</span>
    migrate (undefined<span class="ot"> ::</span> <span class="dt">Machine</span>)
    migrate (undefined<span class="ot"> ::</span> <span class="dt">Part</span>)

  megatron <span class="ot">&lt;-</span> insert <span class="fu">$</span> <span class="dt">Machine</span> <span class="st">&quot;Megatron 5000&quot;</span> <span class="fl">2500.00</span>
  insert <span class="fu">$</span> <span class="dt">Part</span> <span class="st">&quot;Megamaker&quot;</span> <span class="dv">50</span> megatron
  insert <span class="fu">$</span> <span class="dt">Part</span> <span class="st">&quot;Tiny Bolt&quot;</span> <span class="dv">1</span> megatron

  microtron <span class="ot">&lt;-</span> insert <span class="fu">$</span> <span class="dt">Machine</span> <span class="st">&quot;Microtron 12&quot;</span> <span class="fl">19.99</span>
  insert <span class="fu">$</span> <span class="dt">Part</span> <span class="st">&quot;Insignificonium&quot;</span> <span class="dv">2</span> microtron

  partsForMegatron <span class="ot">&lt;-</span> select <span class="fu">$</span> (<span class="dt">MachineField</span> <span class="fu">==.</span> megatron) <span class="ot">`orderBy`</span> [<span class="dt">Asc</span> <span class="dt">PartNameField</span>]
  liftIO <span class="fu">$</span> putStrLn <span class="fu">$</span> <span class="st">&quot;Parts for the Megatron: &quot;</span> <span class="fu">++</span> show partsForMegatron</code></pre>
<p>Declaring the data types is standard Haskell. Just some data types that derive <code>Show</code>. I did notice that I needed to declare <code>cost</code> as a <code>Double</code>. I tried <code>Float</code> initially but it failed.</p>
<p>The first magic appears with <code>mkPersist</code>. Notice it takes a quasiquoted groundhog DSL. I stripped down the declaration here to declare tables with the default settings. If you remove this code then things break. The <code>mkPersist</code> function writes code for you. Its DSL supports <em>a lot</em> of options, and we’ll (dis)cover them in later posts.</p>
<p>Given our declarations we can now run migrations. Here’s is the SQL it generates:</p>
<pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;Machine&quot;</span> (<span class="ot">&quot;id&quot;</span> <span class="dt">INTEGER</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="ot">&quot;modelName&quot;</span> <span class="dt">VARCHAR</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="ot">&quot;cost&quot;</span> <span class="dt">REAL</span> <span class="kw">NOT</span> <span class="kw">NULL</span>)
<span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;Part&quot;</span> (<span class="ot">&quot;id&quot;</span> <span class="dt">INTEGER</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="ot">&quot;partName&quot;</span> <span class="dt">VARCHAR</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="ot">&quot;weight&quot;</span> <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="ot">&quot;machine&quot;</span> <span class="dt">INTEGER</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, <span class="kw">FOREIGN</span> <span class="kw">KEY</span>(<span class="ot">&quot;machine&quot;</span>) <span class="kw">REFERENCES</span> <span class="ot">&quot;Machine&quot;</span>(<span class="ot">&quot;id&quot;</span>))</code></pre>
<p>Not bad! It adds NULL constraints, declares keys, and links the tables together with references.</p>
<p>Next we insert some sample data into the tables. Straightforward. Notice how it then builds a query, but you don’t write SQL directly. Writing the queries in Haskell prevents injection and supposedly allows the queries to easily compose. Groundhog introduces its own operators to connect SQL conditions (called <code>Conds</code>). One such is <code>==.</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>t (<span class="fu">==.</span>)
(<span class="fu">==.</span>)
<span class="ot">  ::</span> (<span class="dt">Database.Groundhog.Expression.Unifiable</span> a b,
      <span class="dt">Database.Groundhog.Expression.Expression</span> db r a,
      <span class="dt">Database.Groundhog.Expression.Expression</span> db r b) <span class="ot">=&gt;</span>
     a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Cond</span> db r</code></pre>
<p>Try building and running the code. Seems to work fine.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'begriffs';

  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    </div>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
  </body>
</html>
