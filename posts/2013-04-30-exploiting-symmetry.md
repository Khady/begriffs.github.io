---
title: Exploiting Symmetry
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
During tonight's <a href="http://www.meetup.com/Mad-Railers/events/103141692/">Madrailers</a> meetup everyone worked on a kata to play the "word morph" game. You pick two arbitrary words and see if one can be converted to the other by changing only one letter at a time where the resulting intermediate words are valid.<br /><br />It's an interesting puzzle, and rather than solve it directly I wanted to discover some general statistics about how connected English words are generally. Rather than choosing two words and seeing if they are connected, I wanted to survey the equivalence classes of this connectedness.<br /><br />I needed to write a program, but I realized that the program can operate on more general structures than simply words and letter manipulations. It turns out that the relation of "differing by one letter" is symmetric, and our program can extend it to a full <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relation</a> and then calculate its equivalence classes on a finite set.<br /><br />To get an idea how this works, let's consider the symmetric relation on integers of "differing by three." The transitive closure of this relation is "differing by any nonzero multiple of three" and the reflexive closure of that is "differing by any multiple of three." The equivalence classes of this last relation on [0,1,2,3,4,5,6,7,8] are [[0,3,6], [1,4,7], [2,5,8]]. Let's look at the general JavaScript code which acts on symmetric relations and see how it behaves on the number example.<br /><br /><script src="https://gist.github.com/begriffs/5486492.js"></script> If we run it, we see that it returns an object with each representative mapping to its class:<br /><br /><script src="https://gist.github.com/begriffs/5486545.js"></script> Returning to the word morph game, I ran&nbsp;<span style="font-family: Courier New, Courier, monospace;">eq_classes()</span> on <span style="font-family: Courier New, Courier, monospace;">/usr/share/dict/words</span> with the word relation of "differing by one letter." The results are interesting. Obviously all one-letter words are equivalent to one another. But so are all two-letter words, and almost all three-letter words. The exceptions are "Eli", "Emm", "Osc", "edh", "its", and "nth" which are not equivalent to any word except themselves. <br /><br />The vast majority of four letter words are all equivalent. There are 158 equivalence classes, most of which have only one word (["ruby"] is one such). After the class containing 5073 words, the next largest classes have four words (such as ["idic", "odic", "Udic", "otic"]). <br /><br />The longer the words become, the more disconnected their classes become. By the time you get to fourteen-letter words, there are 9233 classes among 9765 words. The largest class has seven items: ["invendibleness", "inventibleness", "unvendibleness", "unvendableness", "unbendableness", "unmendableness", "unbondableness"], but there are 8759 single-word classes. <br /><br />What does this tell us? The only reason that every word is not equivalent to every other of the same length is that we tend to avoid certain combinations of letters. Small words are convenient to write, so we have exhausted a greater ratio of valid short words to total short letter combinations. However we are wasteful and choose longer sequences of letters haphazardly, leaving big holes in the larger state space. If our symbols were all phonetic (such as in a language like Telugu which spells by the syllable) I think we would have greater connectedness. <br /><br />I like this challenge not just for what it tells us about English, but as an opportunity to think of algorithms <a href="http://blog.begriffs.com/2013/02/what-might-programming-become.html">more abstractly</a>. That said, somebody in the 1970s has doubtless written a similar function that runs an order of magnitude faster than mine. Let me know if you see a way to improve it.
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/15710420518274380978">
  <div class="css-comment-name js-comment-name">
    Matthew Margolis
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2013-04-30T13:17:27.605Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Very cool.  Thanks for sharing.
  </div>
  <br/>
</div>
</div>
{% endraw %}
