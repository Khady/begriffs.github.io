<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Writing controller specs for a Warp server</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap-readable.min.css" />
    <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="stylesheet" type="text/css" href="../css/minimalist.css" />

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
  </head>
  <body>
    <div class="container">
      <div class="header row">
        <h3><a class="text-muted col-sm-8" href="../">begriffs</a></h3>

        <ul class="col-sm-4 list-inline">
          <li><a class="text-muted" href="../about.html"><i class="fa fa-info-circle"></i></a></li>
          <li><a class="text-muted" href="http://github.com/begriffs"><i class="fa fa-github"></i></a></li>
          <li><a class="text-muted" href="http://twitter.com/begriffs"><i class="fa fa-twitter"></i></a></li>
          <li><a class="text-muted" href="../atom.xml"><i class="fa fa-rss"></i></a></li>
        </ul>
      </div>

      <div class="post-header">
  <h3>Writing controller specs for a Warp server</h3>
  <a href="https://twitter.com/share" class="twitter-share-button pull-right" data-via="begriffs" data-count="none">Tweet</a>
  <h5 class="text-muted">October 19, 2014</h5>
</div>

<div class="content">
  <p>This guide will show you how to configure a Cabal project to test a Warp server (such as Scotty or Yesod) using hspec2. It will allow you to test HTTP requests and responses and to prepare the database before/between steps.</p>
<h3 id="directories-and-cabal">directories and cabal</h3>
<p>Assuming your project code lives in a top-level <code>src</code> directory, create another top-level directory called <code>test</code>. We need to add a new section to the project cabal file that builds the test suite and can access the rest of the project. Append this and adjust package versions to taste:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Test</span><span class="fu">-</span><span class="dt">Suite</span> spec
  <span class="dt">Type</span><span class="fu">:</span>                exitcode<span class="fu">-</span>stdio<span class="fu">-</span><span class="fl">1.0</span>
  <span class="dt">Default</span><span class="fu">-</span><span class="dt">Language</span><span class="fu">:</span>    <span class="dt">Haskell2010</span>
  <span class="dt">Hs</span><span class="fu">-</span><span class="dt">Source</span><span class="fu">-</span><span class="dt">Dirs</span><span class="fu">:</span>      test, src
  ghc<span class="fu">-</span>options<span class="fu">:</span>         <span class="fu">-</span><span class="dt">Wall</span> <span class="fu">-</span><span class="dt">W</span> <span class="fu">-</span><span class="dt">Werror</span>
  <span class="dt">Main</span><span class="fu">-</span><span class="dt">Is</span><span class="fu">:</span>             Main.hs
  <span class="dt">Other</span><span class="fu">-</span><span class="dt">Modules</span><span class="fu">:</span>       <span class="co">-- other project modules</span>
  <span class="dt">Build</span><span class="fu">-</span><span class="dt">Depends</span><span class="fu">:</span>       base
                     , hspec2
                     , hspec<span class="fu">-</span>wai
                     , hspec<span class="fu">-</span>wai<span class="fu">-</span>json
                     , warp
                     , wai</code></pre>
<p>Add <code>test/Main.hs</code>. This is a good place to run other pre-test tasks like loading a database fixture.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import </span><span class="dt">Test.Hspec</span>
<span class="kw">import </span><span class="dt">Spec</span>

<span class="ot">main ::</span> <span class="dt">IO</span> ()
main <span class="fu">=</span> hspec spec</code></pre>
<p>Create <code>test/Spec.hs</code> containing this gobbledygook</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -F -pgmF hspec-discover -optF --no-main #-}</span></code></pre>
<p>This will search for and run all Haskell files <code>spec/**/*Spec.hs</code> as part of the test suite so you do not have to later remember to add new spec files to a configuration list. We’ll see later there is a way to focus the tests when running the suite.</p>
<p>Finally build your project and make it available for testing.</p>
<pre class="sh"><code>$ cabal install -j --enable-tests</code></pre>
<h3 id="beyond-simple-request-specs">beyond simple request specs</h3>
<p>The <a href="https://hackage.haskell.org/package/hspec-wai">hspec-wai</a> package contains some matchers to make things easy. Here’s an example from the readme showing simple reqeusts.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">app ::</span> <span class="dt">IO</span> <span class="dt">Application</span>
app <span class="fu">=</span> S.scottyApp <span class="fu">$</span> <span class="kw">do</span>
  S.get <span class="st">&quot;/&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    S.text <span class="st">&quot;hello&quot;</span>

<span class="ot">spec ::</span> <span class="dt">Spec</span>
spec <span class="fu">=</span> with app <span class="fu">$</span>
  describe <span class="st">&quot;GET /&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    it <span class="st">&quot;responds with 200&quot;</span> <span class="fu">$</span>
      get <span class="st">&quot;/&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="dv">200</span>

    it <span class="st">&quot;responds with 'hello'&quot;</span> <span class="fu">$</span>
      get <span class="st">&quot;/&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;hello&quot;</span>

    it <span class="st">&quot;responds with 200 / 'hello'&quot;</span> <span class="fu">$</span>
      get <span class="st">&quot;/&quot;</span> <span class="ot">`shouldRespondWith`</span> <span class="st">&quot;hello&quot;</span> {matchStatus <span class="fu">=</span> <span class="dv">200</span>}</code></pre>
<p>I like to run the tests with colored output and showing all steps, even those that pass.</p>
<pre class="sh"><code>$ cabal test -j --show-details=always --test-options=&quot;--color&quot;</code></pre>
<p>This is nice and simple, but what if you want to run a customized check on a response? For instance, let’s test that a header value matches a regex. You can do it inside lifted IO.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">Test.Hspec</span>
<span class="kw">import </span><span class="dt">Test.Hspec.Wai</span>
<span class="kw">import </span><span class="dt">Network.HTTP.Types</span>
<span class="kw">import </span><span class="dt">Network.Wai.Test</span> (<span class="dt">SResponse</span>(simpleHeaders,simpleStatus))
<span class="kw">import qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">BS</span>
<span class="kw">import </span><span class="dt">Data.CaseInsensitive</span> (<span class="dt">CI</span>(..))
<span class="kw">import </span><span class="dt">Text.Regex.TDFA</span> ((=~))

<span class="ot">matchHeader ::</span> <span class="dt">CI</span> <span class="dt">BS.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Header</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span>
matchHeader name valRegex headers <span class="fu">=</span>
  maybe <span class="dt">False</span> (<span class="fu">=~</span> valRegex) <span class="fu">$</span> lookup name headers

<span class="ot">spec ::</span> <span class="dt">Spec</span>
spec <span class="fu">=</span> with app <span class="fu">$</span>
  describe <span class="st">&quot;GET /list&quot;</span> <span class="fu">$</span>
    it <span class="st">&quot;responds with valid range headers&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
      r <span class="ot">&lt;-</span> request methodGet <span class="st">&quot;/list&quot;</span>
             [<span class="st">&quot;Range-Unit&quot;</span> <span class="fu">&lt;:&gt;</span> <span class="st">&quot;items&quot;</span>, <span class="st">&quot;Range&quot;</span> <span class="fu">&lt;:&gt;</span> <span class="st">&quot;0-9&quot;</span>]

      liftIO <span class="fu">$</span> <span class="kw">do</span>
        simpleHeaders r <span class="ot">`shouldSatisfy`</span>
          matchHeader <span class="st">&quot;Content-Range&quot;</span> <span class="st">&quot;^0-[0-9]+/[0-9]+$&quot;</span>
        simpleStatus r <span class="ot">`shouldBe`</span> partialContent206</code></pre>
<p>How do the tests know where to send requests? The trick is at the beginning in the <code>with</code> function which is an alias for <code>before</code> and defined in <code>hspec-wai</code> rather than <code>hspec</code> itself.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">before ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">SpecWith</span> a <span class="ot">-&gt;</span> <span class="dt">Spec</span></code></pre>
<p>We give it an IO action, in this case <code>app :: IO Application</code> and it builds <code>SpecWith Application</code> which is a Reader monad that future test steps can query. For instance, the <code>request</code> method grabs the application internally with <code>getApp</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | Perform a request to the application under test, with specified HTTP</span>
<span class="co">-- method, request path, headers and body.</span>
<span class="ot">request ::</span> <span class="dt">Method</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">Header</span>] <span class="ot">-&gt;</span> <span class="dt">LB.ByteString</span>
                  <span class="ot">-&gt;</span> <span class="dt">WaiSession</span> <span class="dt">SResponse</span>
request method path headers body <span class="fu">=</span>
  getApp <span class="fu">&gt;&gt;=</span> liftIO <span class="fu">.</span> runSession (Wai.srequest <span class="fu">$</span> <span class="dt">SRequest</span> req body)
  <span class="kw">where</span>
    req <span class="fu">=</span> setPath defaultRequest
            {requestMethod <span class="fu">=</span> method, requestHeaders <span class="fu">=</span> headers} path</code></pre>
<p>Really <code>getApp</code> is a glorified <code>ask</code>, along with type constraints that would make it fail to compile if the surrounding test was not using <code>SpecWith Application</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">getApp ::</span> <span class="dt">WaiSession</span> <span class="dt">Application</span>
getApp <span class="fu">=</span> <span class="dt">WaiSession</span> ask</code></pre>
<p>Another less explicitly monadic way to interact with the test subject is using an argument in the <code>it</code> function. What goes into <code>with</code> can come out in <code>it</code>.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">spec ::</span> <span class="dt">Spec</span>
spec <span class="fu">=</span> with (return <span class="dv">42</span>)<span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Int</span> <span class="fu">$</span>
  describe <span class="st">&quot;This magical number&quot;</span> <span class="fu">$</span>
    it <span class="st">&quot;is bigger than 40&quot;</span> <span class="fu">$</span> \n <span class="ot">-&gt;</span>
      n <span class="ot">`shouldSatisfy`</span> (<span class="fu">&gt;</span><span class="dv">40</span>)</code></pre>
<p>Perhaps it’s silly as stated, but imagine the integer is a database connection instead. In fact this leads to the next topic…</p>
<h3 id="cleaning-the-db-between-tests">cleaning the db between tests</h3>
<p>In contrast to the <code>before</code> family of functions which use <code>SpecWith a</code> types, the <code>after</code> and <code>around</code> functions use <code>ActionWith a</code>. Internally it’s not much to speak of, but the alias will make our actions’ types read cleaner.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ActionWith</span> a <span class="fu">=</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</code></pre>
<p>What’s a good use case for around actions? Cleaning up the environment so tests do not pollute each other’s state is one. Here’s an example of rolling back any changes to a Postgres database after each test.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Test.Hspec</span>
<span class="kw">import </span><span class="dt">Database.HDBC</span>
<span class="kw">import </span><span class="dt">Database.HDBC.PostgreSQL</span>
<span class="kw">import </span><span class="dt">Control.Exception.Base</span> (bracket)

<span class="ot">withDatabaseConnection ::</span> <span class="dt">ActionWith</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
withDatabaseConnection <span class="fu">=</span> bracket openConnection disconnect
  <span class="kw">where</span> openConnection <span class="fu">=</span> connectPostgreSQL' <span class="st">&quot;postgres://etcetc&quot;</span>

<span class="ot">withRollback ::</span> <span class="dt">ActionWith</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
withRollback action <span class="fu">=</span> withDatabaseConnection <span class="fu">$</span> \c <span class="ot">-&gt;</span> <span class="kw">do</span>
  runRaw c <span class="st">&quot;begin;&quot;</span>
  action c
  rollback c

<span class="ot">spec ::</span> <span class="dt">Spec</span>
spec <span class="fu">=</span> around withRollback <span class="fu">$</span>
  describe <span class="st">&quot;inserting with abandon&quot;</span> <span class="fu">$</span>
    it <span class="st">&quot;does all kinds of things&quot;</span> <span class="fu">$</span> \conn <span class="ot">-&gt;</span>
      <span class="co">-- here we can use the connection and be assured</span>
      <span class="co">-- our sql commands will be rolled back</span></code></pre>
<p>One tiny but important detail is the choice of <code>connectPostgreSQL'</code> (with an apostrophe). The non-prime connect function in HDBC.PostgreSQL enables auto-commit. This means it peforms every statement in a transaction, which will cause surprises for you. The prime version is for manual transaction management like we are using here.</p>
<p>Simply combine the <code>with app</code> and <code>around withRollback</code> to do controller tests that include database cleaning. And don’t forget you can perform an action before the entire suite runs inside the <code>Main.hs</code> we created.</p>
</div>

    </div>

    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="../js/flowplayer.min.js"></script>
    <!-- Aww yiss, obsessively watching my numbers! -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49573102-1', 'begriffs.com');
      ga('send', 'pageview');
    </script>

    <footer class="container">
      <p>I'm begriffs, journeying from web ephemera to the timeless world of data. <a href="mailto:joe@begriffs.com" role="button">Contact me.</a></p>
    </footer>
  </body>
</html>
