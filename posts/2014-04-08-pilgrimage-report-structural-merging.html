<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Tikhon Jelvis' ideas about Structural Merging</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap-readable.min.css" />
    <link rel="stylesheet" type="text/css" href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    <link rel="stylesheet" type="text/css" href="../css/minimalist.css" />

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
  </head>
  <body>
    <div class="container">
      <div class="header row">
        <h3><a class="text-muted col-sm-8" href="../">begriffs</a></h3>

        <ul class="col-sm-4 list-inline">
          <li><a class="text-muted" href="../about.html"><i class="fa fa-info-circle"></i></a></li>
          <li><a class="text-muted" href="http://github.com/begriffs"><i class="fa fa-github"></i></a></li>
          <li><a class="text-muted" href="http://twitter.com/begriffs"><i class="fa fa-twitter"></i></a></li>
          <li><a class="text-muted" href="../atom.xml"><i class="fa fa-rss"></i></a></li>
        </ul>
      </div>

      <div class="post-header">
  <h3>Tikhon Jelvis' ideas about Structural Merging</h3>
  <a href="https://twitter.com/share" class="twitter-share-button pull-right" data-via="begriffs" data-count="none">Tweet</a>
  <h5 class="text-muted">April  8, 2014</h5>
</div>

<div class="content">
  <p>This afternoon I paired with Tikhon. He’s a Haskeller, researcher, and the organizer of the SF Types, Theorems, and Programming Languages group. His <a href="https://github.com/TikhonJelvis/Cow">project</a> is to extend the unix commands <code>diff</code> and <code>merge</code> to understand and work better on JavaScript code.</p>
<p>As a product of the Unix tradition the standard <code>diff</code> program operates line by line between files. This affects not just diff itself but programs like git that rely on it. Have you ever changed a program in a way that does not affect its operation such as changing indentation and then been forced to make a big git commit? Have you ever changed the name of a variable and caused a big fragmented commit? Tikhon believes that small changes of meaning should appear as small diffs and the reason that they currently don’t is that we still think in terms of teletypes rather than syntax.</p>
<p>Most importantly Tikhon realized that operating crudely on lines can create merge conflicts when there needn’t be any. For instance, consider this original file:</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">foo</span> (a, b) {
  <span class="kw">return</span> a + b;
}

<span class="kw">function</span> <span class="fu">foo2</span> (a, b) {
  <span class="kw">return</span> a - b;
}</code></pre>
<p>One person edits it by moving one function inside the scope of the other.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">foo</span> (a, b) {
  <span class="kw">return</span> a + b;

  <span class="kw">function</span> <span class="fu">foo2</span> (a, b) {
    <span class="kw">return</span> a - b;
  }
}</code></pre>
<p>Another edits it by changing variable names.</p>
<pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="fu">foo</span> (a, b) {
  <span class="kw">return</span> a + b;
}

<span class="kw">function</span> <span class="fu">foo2</span> (c, d) {
  <span class="kw">return</span> c - d;
}</code></pre>
<p>The merge fails! Resolution requires accepting one version and manually adding the changes from the other.</p>
<pre class="sourceCode diff"><code class="sourceCode diff">function foo (a, b) {
  return a + b;

<span class="st">&lt;&lt;&lt;&lt;&lt;&lt;&lt; move.js</span>
  function foo2 (a, b) {
    return a - b;
  }
<span class="kw">=======</span>
function foo2 (c, d) {
  return c - d;
<span class="ot">&gt;&gt;&gt;&gt;&gt;&gt;&gt; rename.js</span>
}</code></pre>
<p>His solution: a <em>structural</em> merge. A traditional diff sees each of these changes as many lines, whereas each of the files being merged differs by only a single structural change, and those changes can be harmlessly resolved. In terms of syntax, the first change (moving foo2 inside foo) looks like this</p>
<div class="figure">
<img src="../images/tree-1.png" alt="Moving foo" />
<p class="caption">Moving foo</p>
</div>
<p>The second (renaming the variables) looks like this</p>
<div class="figure">
<img src="../images/tree-2.png" alt="Renaming variables" />
<p class="caption">Renaming variables</p>
</div>
<p>These representations are created using the Zhang-Shasha tree edit-distance algorithm. It indicates “tree diff” in terms of the node operations <em>move</em>, <em>relabel</em>, <em>add</em>, and <em>delete</em>. The algorithm finds the minimum number of applications of these rules to transform one tree into another.</p>
<p>Interestingly if we create a tree diff of tree diffs themselves we can use it to display more meaningful merge conflicts. The diff of the two diff trees above looks like this</p>
<div class="figure">
<img src="../images/tree-diff.png" alt="Tree diff" />
<p class="caption">Tree diff</p>
</div>
<p>A second pass with a simplifying algorithm shows there is exactly one edit operation introduced by each change. A structural merge program can interactively ask the user which edit operation to apply (and can do them both if requested).</p>
<p>Tikhon’s big hurdle is to make his tree diff fast. As he quipped, “[it runs in] exponential time…I’m not a fan.” The solution is dynamic programming, and in a lazy language like Haskell with immutable data structures it only takes a tiny change in a program to automatically memoize functions and enable dynamic programming. We spent the day investigating how to do it for his tree diff function, but began by playing with it in the simpler problem of string edit distance.</p>
<p>Let me show you the trick first. It uses laziness and co-recursion to make the function and its lookup table always keep one step ahead of each other in a magical circle. Observe how it is used to generate Fibonacci numbers.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">fibs <span class="fu">=</span> <span class="dv">0</span> <span class="fu">:</span> <span class="dv">1</span> <span class="fu">:</span> zipWith (<span class="fu">+</span>) fibs (drop <span class="dv">1</span> fibs)

<span class="co">-- take 10 fibs</span>
<span class="co">-- [0,1,1,2,3,5,8,13,21,34]</span></code></pre>
<p>Let’s see a naive implementation of string edit distance and how to transform it with The Trick. It’s a Haskell implementation of the Wagner–Fischer algorithm which recursively calculates the edit distance of every initial segment of the two strings eventually working up to the original strings. Using the edit operations insert, delete, and substitute it can be expressed succinctly as</p>
<div class="figure">
<img src="../images/wagner-fischer.png" alt="Wagner fischer" />
<p class="caption">Wagner fischer</p>
</div>
<p>Translated to Haskell it becomes</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">editDistance ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
editDistance xs ys <span class="fu">=</span> dist m n
  <span class="kw">where</span>
  (m,n) <span class="fu">=</span> (length xs, length ys)
  x <span class="fu">=</span> array (<span class="dv">1</span>,m) (zip [<span class="dv">1</span><span class="fu">..</span>] xs)
  y <span class="fu">=</span> array (<span class="dv">1</span>,n) (zip [<span class="dv">1</span><span class="fu">..</span>] ys)

<span class="ot">  dist ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
  dist <span class="dv">0</span> j <span class="fu">=</span> j
  dist i <span class="dv">0</span> <span class="fu">=</span> i
  dist i j <span class="fu">=</span> minimum [
      (dist (i<span class="fu">-</span><span class="dv">1</span>) j    ) <span class="fu">+</span> <span class="dv">1</span>,
      (dist i     (j<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">+</span> <span class="dv">1</span>,
      <span class="kw">if</span> x <span class="fu">!</span> i <span class="fu">==</span> y <span class="fu">!</span> j <span class="kw">then</span>     dist (i<span class="fu">-</span><span class="dv">1</span>) (j<span class="fu">-</span><span class="dv">1</span>)
                        <span class="kw">else</span> <span class="dv">1</span> <span class="fu">+</span> dist (i<span class="fu">-</span><span class="dv">1</span>) (j<span class="fu">-</span><span class="dv">1</span>)
    ]</code></pre>
<p>The trick to make it fast is to co-recursively fill in a lookup table with the edit distances of initial segments, and to calculate edit distances…by referencing the table. Mind = blown.</p>
<p>After implementing the function above that returns merely the minimum edit distance, we augmented it to return an array of the actual edit actions needed. Got into some performance problems of repeatedly calculating the length of those arrays when checking for the minimum, but found a way around that problem.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">editDistance ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>
editDistance xs ys <span class="fu">=</span> table <span class="fu">!</span> (m,n)
  <span class="kw">where</span>
  (m,n) <span class="fu">=</span> (length xs, length ys)
  x     <span class="fu">=</span> array (<span class="dv">1</span>,m) (zip [<span class="dv">1</span><span class="fu">..</span>] xs)
  y     <span class="fu">=</span> array (<span class="dv">1</span>,n) (zip [<span class="dv">1</span><span class="fu">..</span>] ys)

<span class="ot">  table ::</span> <span class="dt">Array</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="dt">Int</span>
  table <span class="fu">=</span> array bnds [(ij, dist ij) <span class="fu">|</span> ij <span class="ot">&lt;-</span> range bnds]
  bnds  <span class="fu">=</span> ((<span class="dv">0</span>,<span class="dv">0</span>),(m,n))

  dist (<span class="dv">0</span>,j) <span class="fu">=</span> j
  dist (i,<span class="dv">0</span>) <span class="fu">=</span> i
  dist (i,j) <span class="fu">=</span> minimum [
      table <span class="fu">!</span> (i<span class="fu">-</span><span class="dv">1</span>,j) <span class="fu">+</span> <span class="dv">1</span>,
      table <span class="fu">!</span> (i,j<span class="fu">-</span><span class="dv">1</span>) <span class="fu">+</span> <span class="dv">1</span>,
      <span class="kw">if</span> x <span class="fu">!</span> i <span class="fu">==</span> y <span class="fu">!</span> j <span class="kw">then</span>     table <span class="fu">!</span> (i<span class="fu">-</span><span class="dv">1</span>,j<span class="fu">-</span><span class="dv">1</span>)
                        <span class="kw">else</span> <span class="dv">1</span> <span class="fu">+</span> table <span class="fu">!</span> (i<span class="fu">-</span><span class="dv">1</span>,j<span class="fu">-</span><span class="dv">1</span>)
    ]</code></pre>
<p>What remains is to translate this nice memoized string edit distance to trees using tree edit operations rather than string operations. Notice the lookup table we used above is a two-dimensional array indexed by the length of segments. To translate the lookup table strategy to trees we need a way to uniquely name partial-traversals, which we could do by choosing the number of hops along the traversal to be the “index.” (We experimented with using a Haskell Map keyed off the trees but that was really slow.) Ultimately we did not complete the refactor to make the tree diff sub-exponential speed, but we discovered how it will be done.</p>
</div>

    </div>

    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="../js/flowplayer.min.js"></script>
    <!-- Aww yiss, obsessively watching my numbers! -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49573102-1', 'begriffs.com');
      ga('send', 'pageview');
    </script>

    <footer class="container">
      <p>I'm begriffs, journeying from web ephemera to the timeless world of data. <a href="mailto:joe@begriffs.com" role="button">Contact me.</a></p>
    </footer>
  </body>
</html>
