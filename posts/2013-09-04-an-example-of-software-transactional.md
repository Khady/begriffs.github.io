---
title: An example of software transactional memory
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
<div>Yesterday I took a train for hours to consult a Haskell <a href="https://github.com/sciolizer">guru</a>. I now bring unto you his wisdom.</div><div><br /></div>Let's take advantage of Haskell's efficient threads and the elegance of the STM pattern to write a short program to spawn workers and consume the results as they are generated. It may help to watch this <a href="http://blip.tv/oreilly-open-source-convention/oscon-2007-simon-peyton-jones-322473">presentation</a> about STM (it is not specific to Haskell)&nbsp;before looking at my example code.<br /><div><br /></div><div><div>Part of what might look unfamiliar about the code is its use of&nbsp;<span style="font-family: Courier New, Courier, monospace;">Data.Sequence</span>. That library provides a queue structure which allows efficient insertion to the beginning or end. Internally it is a tree, so we use a trick to pattern-match it in a function. But one thing at a time.</div></div><div><br /></div><div>Ready, set, read.</div><code data-gist-hide-footer="true" data-gist-id="6433963"></code><br /><div>Here is what this program does in general. There are two worker threads and a consumer. Each worker appends to its own queue of results. The consumer reads off of whichever queue has new values ready, adds the value to a running total, and prints the total so far. But it works differently than traditional lock-based concurrency because the pieces of code are done inside transactions which can be composed.</div><div><br /></div><div>The secret ingredients are <span style="font-family: Courier New, Courier, monospace;">atomically</span>, <span style="font-family: Courier New, Courier, monospace;">retry</span>, and <span style="font-family: Courier New, Courier, monospace;">orElse</span>. Doing a collection of actions atomically means they happen in a transaction -- either all or none of them will occur. If two threads try to modify the same variables at once within distinct atomic blocks then Haskell will consult a log of operations, reset the variables and try again. What's cool is that a programmer using the library can work in the "high level" language of STM and specify how to compose atomic blocks including when to explicitly retry. Our example is the consumer function.</div><div><br /></div><div>On line 19 it enters into an atomic block which tries taking elements from a sequence <span style="font-family: Courier New, Courier, monospace;">p</span> or a sequence <span style="font-family: Courier New, Courier, monospace;">q</span>. &nbsp;It does this with another function we defined called pull. The pull function unwraps the STM sequence variable and checks if it has an element in it. If it finds one it updates another STM variable and returns it wrapped back up. (I'll get to what this wrapping up means.) If pull detects that the sequence is empty then it calls <span style="font-family: Courier New, Courier, monospace;">retry</span>.</div><div><br /></div><div>What does <span style="font-family: Courier New, Courier, monospace;">retry</span> do? It goes back to the start of the atomic block on line 19, which looks for what to try next. In this case it sees an <span style="font-family: Courier New, Courier, monospace;">orElse</span>, and it knows it has just tried pulling <span style="font-family: Courier New, Courier, monospace;">p</span>, so it tries pull on <span style="font-family: Courier New, Courier, monospace;">q</span>, which is the second argument to <span style="font-family: Courier New, Courier, monospace;">orElse</span>. So look at that, we composed some options into an atomic block!</div><div><br /></div><div>OK, but you ask: what if pull <span style="font-family: Courier New, Courier, monospace;">q</span> finds an empty sequence and retries as well? More Haskelly magic, that's what. It suspends the current thread, but it somehow knows the variables referred to by the block and will awaken the thread if anything else updates the variables and will try again, starting with pull <span style="font-family: Courier New, Courier, monospace;">p</span>. (Remember that "pull" is a custom function we wrote ourselves, it's not part of the STM library.)</div><div><br /></div><div>I learned more about Haskell programming by trying to construct this program. Joshua helped me when I got stuck but let me flail around for a while first, which was helpful. Let me summarize the ways I learned to think about writing these functions.</div><div><br /></div><div>Whenever you mutate data you do it inside an IO monad. When you're working "inside a monad" you can use the "do" command for concision. However you have to consistently stay inside the same kind of monad for each line of the do block. Looking at the type signatures of some of the functions involved in this program can help orient you to the general flavor of each of the do blocks.</div><div><br /></div><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="6433789"></code><br /><div>Look how everything inside <span style="font-family: Courier New, Courier, monospace;">main</span> returns <span style="font-family: Courier New, Courier, monospace;">IO</span>. This means <span style="font-family: Courier New, Courier, monospace;">main</span> is concerned with changing things. It gets stuff done. So do <span style="font-family: Courier New, Courier, monospace;">work</span> and <span style="font-family: Courier New, Courier, monospace;">consume</span>. However pull is an entirely different animal. Everything inside its do block returns type STM. I think of things that return STM as just orchestrating how things will change when they do change. STM variables direct the evil eye of Haskell to watch things changing and reset them as appropriate. Doing the <span style="font-family: Courier New, Courier, monospace;">readTVal</span> and <span style="font-family: Courier New, Courier, monospace;">retry</span> and all that is like setting the dominoes into an interesting pattern. Calling <span style="font-family: Courier New, Courier, monospace;">atomically</span> is like knocking down the first domino, as its return type of <span style="font-family: Courier New, Courier, monospace;">IO</span> would indicate.</div><div><br /></div><div>Other random notes about the code. Don't worry about the <span style="font-family: Courier New, Courier, monospace;">viewl</span>, <span style="font-family: Courier New, Courier, monospace;">&lt;|</span><span style="font-family: inherit;">, and </span><span style="font-family: Courier New, Courier, monospace;">:&lt;</span> weirdness. It is defined to pattern-match and modify a <span style="font-family: Courier New, Courier, monospace;">Data.Sequence</span>. They are specifics of a library. Module writers are free to define custom operators so you'll see a lot of them introduced. Also check out the "backwards bind" on lines 19 and 25. Joshua advises that if you're using the regular bind your code is unclear because other operators like function composition work from right to left. If you match that order with a backwards bind you can scan a line uniformly from end to beginning. For instance "read the variable, add a value to it, write it (on line 25).</div><div><br /></div><div>Finally, it's a good idea to declare the type of your functions. Haskell can deduce it just fine, so it might feel redundant, but when a type error ever happens in the way you use your functions it will tend to be reported high up the call stack. That makes it hard for you to debug. So throw type declarations liberally so the errors are matched closer to their cause.</div><div><br /></div><div>So that's STM in a nutshell. Go forth and concur.</div>
</div>
<div class="css-full-comments-content js-full-comments-content">
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/07389927430214750440">
  <div class="css-comment-name js-comment-name">
    bst
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2013-09-04T12:13:21.165Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    Thanks for this. I&#39;ve been using Haskell for small programs for quite a while now, but I haven&#39;t much looked at how to use STM. This is a nice introduction, and now I need a side-project so that I can play around with it :-)
  </div>
  <br/>
</div>
<div class="css-full-comment js-full-comment">
  <div class="css-comment-user-link js-comment-user-link">
  <a href="http://www.blogger.com/profile/05140850890065532317">
  <div class="css-comment-name js-comment-name">
    David
  </div>
  </a>
  <div class="css-comment-date js-comment-date">
    2013-09-05T17:13:51.780Z
  </div>
  </div>
  <div class="css-comment-content js-comment-content">
    A worthwhile perspective (though not the only valid one) points out that an IO value itself is &quot;indicating how things change&quot; as well, and only has an effect when combined into main (directly or indirectly).
  </div>
  <br/>
</div>
</div>
{% endraw %}
