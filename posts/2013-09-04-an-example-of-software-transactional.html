<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>An example of software transactional memory</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap-readable.min.css" />
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  </head>
  <body>
    <div class="container">
      <div class="header row">
        <h3><a class="text-muted col-sm-8" href="../">begriffs</a></h3>

        <ul class="col-sm-4 list-inline">
          <li><a class="text-muted" href="../about.html"><i class="fa fa-info-circle"></i></a></li>
          <li><a class="text-muted" href="http://github.com/begriffs"><i class="fa fa-github"></i></a></li>
          <li><a class="text-muted" href="http://twitter.com/begriffs"><i class="fa fa-twitter"></i></a></li>
          <li><a class="text-muted" href="../atom.xml"><i class="fa fa-rss"></i></a></li>
        </ul>
      </div>

      <div class="post-header">
  <h3>An example of software transactional memory</h3>
  <a href="https://twitter.com/share" class="twitter-share-button pull-right" data-via="begriffs" data-count="none">Tweet</a>
  <h5 class="text-muted">September  4, 2013</h5>
</div>

<div class="content">
  <p>Yesterday I took a train for hours to consult a Haskell <a href="https://github.com/sciolizer">guru</a>. I now bring unto you his wisdom.</p>
<p>Let’s take advantage of Haskell’s efficient threads and the elegance of the STM pattern to write a short program to spawn workers and consume the results as they are generated. It may help to watch this <a href="http://blip.tv/oreilly-open-source-convention/oscon-2007-simon-peyton-jones-322473">presentation</a> about STM (it is not specific to Haskell) before looking at my example code.</p>
<p>Part of what might look unfamiliar about the code is its use of <code>Data.Sequence</code>. That library provides a queue structure which allows efficient insertion to the beginning or end. Internally it is a tree, so we use a trick to pattern-match it in a function. But one thing at a time.</p>
<p>Ready, set, read.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Data.Sequence</span>
<span class="kw">import </span><span class="dt">Control.Monad</span>
<span class="kw">import </span><span class="dt">Control.Concurrent</span>
<span class="kw">import </span><span class="dt">Control.Concurrent.STM</span>

main <span class="fu">=</span> <span class="kw">do</span>
  queue2 <span class="ot">&lt;-</span> atomically <span class="fu">$</span> newTVar empty
  queue1 <span class="ot">&lt;-</span> atomically <span class="fu">$</span> newTVar empty
  total <span class="ot">&lt;-</span> atomically <span class="fu">$</span> newTVar <span class="dv">0</span>
  forkIO <span class="fu">$</span> <span class="dv">100</span> <span class="ot">`replicateM_`</span> (work queue1 <span class="fu">&gt;&gt;</span> threadDelay <span class="dv">100000</span>)
  forkIO <span class="fu">$</span> <span class="dv">100</span> <span class="ot">`replicateM_`</span> (work queue2 <span class="fu">&gt;&gt;</span> threadDelay <span class="dv">100000</span>)
  <span class="dv">200</span> <span class="ot">`replicateM_`</span> consumer total queue1 queue2

<span class="ot">work ::</span> <span class="dt">TVar</span> (<span class="dt">Seq</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
work queue <span class="fu">=</span> atomically <span class="fu">$</span> modifyTVar queue (<span class="dv">1</span> <span class="fu">&lt;|</span>)

<span class="ot">consumer ::</span> <span class="dt">TVar</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> (<span class="dt">Seq</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">TVar</span> (<span class="dt">Seq</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
consumer total p q <span class="fu">=</span> print <span class="fu">=&lt;&lt;</span> atomically (pull p <span class="ot">`orElse`</span> pull q) <span class="kw">where</span>
  pull queue <span class="fu">=</span> <span class="kw">do</span>
    seq <span class="ot">&lt;-</span> readTVar queue
    <span class="kw">case</span> viewl seq <span class="kw">of</span>
      h <span class="fu">:&lt;</span> rest <span class="ot">-&gt;</span> <span class="kw">do</span>
        writeTVar queue rest
        writeTVar total <span class="fu">.</span> (<span class="fu">+</span>h) <span class="fu">=&lt;&lt;</span> readTVar total
        readTVar total
      <span class="dt">EmptyL</span> <span class="ot">-&gt;</span> retry</code></pre>
<p>Here is what this program does in general. There are two worker threads and a consumer. Each worker appends to its own queue of results. The consumer reads off of whichever queue has new values ready, adds the value to a running total, and prints the total so far. But it works differently than traditional lock-based concurrency because the pieces of code are done inside transactions which can be composed.</p>
<p>The secret ingredients are <code>atomically</code>, <code>retry</code>, and <code>orElse</code>. Doing a collection of actions atomically means they happen in a transaction – either all or none of them will occur. If two threads try to modify the same variables at once within distinct atomic blocks then Haskell will consult a log of operations, reset the variables and try again. What’s cool is that a programmer using the library can work in the “high level” language of STM and specify how to compose atomic blocks including when to explicitly retry. Our example is the consumer function.</p>
<p>On line 19 it enters into an atomic block which tries taking elements from a sequence <code>p</code> or a sequence <code>q</code>. It does this with another function we defined called pull. The pull function unwraps the STM sequence variable and checks if it has an element in it. If it finds one it updates another STM variable and returns it wrapped back up. (I’ll get to what this wrapping up means.) If pull detects that the sequence is empty then it calls <code>retry</code>.</p>
<p>What does <code>retry</code> do? It goes back to the start of the atomic block on line 19, which looks for what to try next. In this case it sees an <code>orElse</code>, and it knows it has just tried pulling <code>p</code>, so it tries pull on <code>q</code>, which is the second argument to <code>orElse</code>. So look at that, we composed some options into an atomic block!</p>
<p>OK, but you ask: what if pull <code>q</code> finds an empty sequence and retries as well? More Haskelly magic, that’s what. It suspends the current thread, but it somehow knows the variables referred to by the block and will awaken the thread if anything else updates the variables and will try again, starting with pull <code>p</code>. (Remember that “pull” is a custom function we wrote ourselves, it’s not part of the STM library.)</p>
<p>I learned more about Haskell programming by trying to construct this program. Joshua helped me when I got stuck but let me flail around for a while first, which was helpful. Let me summarize the ways I learned to think about writing these functions.</p>
<p>Whenever you mutate data you do it inside an IO monad. When you’re working “inside a monad” you can use the “do” command for concision. However you have to consistently stay inside the same kind of monad for each line of the do block. Looking at the type signatures of some of the functions involved in this program can help orient you to the general flavor of each of the do blocks.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="fu">:</span>t newTVar
<span class="ot">newTVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TVar</span> a)
<span class="fu">&gt;</span> <span class="fu">:</span>t readTVar
<span class="ot">readTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a
<span class="fu">&gt;</span> <span class="fu">:</span>t writeTVar
<span class="ot">writeTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()
<span class="fu">&gt;</span> <span class="fu">:</span>t modifyTVar
<span class="ot">modifyTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">STM</span> ()
 
<span class="fu">&gt;</span> <span class="fu">:</span>t retry
<span class="ot">retry ::</span> <span class="dt">STM</span> a
<span class="fu">&gt;</span> <span class="fu">:</span>t orElse
<span class="ot">orElse ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a
 
<span class="fu">&gt;</span> <span class="fu">:</span>t atomically
<span class="ot">atomically ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a
<span class="fu">&gt;</span> <span class="fu">:</span>t forkIO
<span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></code></pre>
<p>Look how everything inside <code>main</code> returns <code>IO</code>. This means <code>main</code> is concerned with changing things. It gets stuff done. So do <code>work</code> and <code>consume</code>. However pull is an entirely different animal. Everything inside its do block returns type STM. I think of things that return STM as just orchestrating how things will change when they do change. STM variables direct the evil eye of Haskell to watch things changing and reset them as appropriate. Doing the <code>readTVal</code> and <code>retry</code> and all that is like setting the dominoes into an interesting pattern. Calling <code>atomically</code> is like knocking down the first domino, as its return type of <code>IO</code> would indicate.</p>
<p>Other random notes about the code. Don’t worry about the <code>viewl</code>, <code>&lt;|</code>, and <code>:&lt;</code> weirdness. It is defined to pattern-match and modify a <code>Data.Sequence</code>. They are specifics of a library. Module writers are free to define custom operators so you’ll see a lot of them introduced. Also check out the “backwards bind” on lines 19 and 25. Joshua advises that if you’re using the regular bind your code is unclear because other operators like function composition work from right to left. If you match that order with a backwards bind you can scan a line uniformly from end to beginning. For instance “read the variable, add a value to it, write it (on line 25).</p>
<p>Finally, it’s a good idea to declare the type of your functions. Haskell can deduce it just fine, so it might feel redundant, but when a type error ever happens in the way you use your functions it will tend to be reported high up the call stack. That makes it hard for you to debug. So throw type declarations liberally so the errors are matched closer to their cause.</p>
<p>So that’s STM in a nutshell. Go forth and concur.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'begriffs';

  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    </div>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <!-- Aww yiss, obsessively watching my numbers! -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49573102-1', 'begriffs.com');
      ga('send', 'pageview');
    </script>
  </body>
</html>
