<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Thoughts for a new API server stack</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap-readable.min.css" />
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  </head>
  <body>
    <div class="container">
      <div class="header row">
        <h3><a class="text-muted col-sm-9" href="../">begriffs</a></h3>

        <ul class="col-sm-3 list-inline">
          <li><a class="text-muted" href="../about.html"><i class="fa fa-info-circle"></i></a></li>
          <li><a class="text-muted" href="http://github.com/begriffs"><i class="fa fa-github"></i></a></li>
          <li><a class="text-muted" href="http://twitter.com/begriffs"><i class="fa fa-twitter"></i></a></li>
        </ul>
      </div>

      <div class="post-header">
  <h3>Thoughts for a new API server stack</h3>
  <a href="https://twitter.com/share" class="twitter-share-button pull-right" data-via="begriffs" data-count="none">Tweet</a>
  <h5 class="text-muted">March  1, 2014</h5>
</div>

<div class="content">
  <p>If you could choose any technologies to build your next API server, what would they be?</p>
<p>I’ve been thinking a lot about this question because I know we can do better than the status quo. I feel that the current generation of web frameworks are lacking because they make us focus on MVC procedures rather than the data itself.</p>
<p>Before I jump into coding my first proof-of-concept, I feel like talking it out in a blog post. If you disagree with my approach let’s discuss.</p>
<ol style="list-style-type: decimal">
<li>Start with <strong>PostgreSQL</strong>. It is a very capable database, and we can use its built-in features rather than rewriting them. It might not be the right choice for certain applications (like graph connectedness queries), but it is perfect for traditional crud apps. It can handle geospatial and full text searching as well.</li>
<li>Store database migrations in a git repo and use <a href="https://github.com/depesz/Versioning"><strong>depesz/Versioning</strong></a> (see his <a href="http://www.depesz.com/2010/08/22/versioning/">blog post</a>). If you’ve used Rails then you know about migrations, but depesz’s are better. Have you ever switched branches in your code and been unable to migrate because some of your migrations are on a different branch? I don’t think this library has that problem (but I haven’t tried it yet). Unlike the Rails model, this one recognizes that migrations form a dependency tree, not a straight line, and it keeps fuller record in the db of migration history. (<strong>UPDATE</strong>: <a href="https://github.com/theory/sqitch">theory/sqitch</a> looks even better)</li>
<li>Use <strong>test-driven development</strong> in migrations. The good thing about relational databases is there is less to test in the first place. By using constraints you can often just declare what you want. But for more complicated things like subtle row ordering or joins we can include fixtures and tests with each migration. Perhaps wrap the migration in a transaction that ensures the tests fail before migration and succeed afterward, else roll back the whole thing.</li>
<li>Define <strong>views</strong> that will be the face of the API. Don’t allow public access to any underlying tables. Postgres 9.3 now supports <a href="http://michael.otacoo.com/postgresql-2/postgres-9-3-feature-highlight-auto-updatable-views/">auto-updatable</a> views, so you don’t have to create stored procedures to change data. Even views with aggregate functions and joins can be updatable, as long as you write triggers to intercept the update.</li>
<li><strong>Add HTTP caching</strong> hints to views as <a href="http://www.postgresql.org/docs/9.3/static/sql-comment.html">comments</a>. The comment can be SQL which produces a single-row table that can contain any of these columns: <code>Expires</code>, <code>max_age</code>, <code>Last-Modified</code>, and <code>ETag</code>. The API server can run the comment query in a production environment to decide what headers to set.</li>
<li><strong>Version</strong> the views with schemas. Backward compatibility is important for an API, so we should address it early. For each major (breaking) version create a schema like v1 or v2. Consumers of the API will have their queries executed within a schema depending on the version they request. Also views can be accessed across schemas with the <code>search_path</code> setting (to fall back to old versions of whichever views you don’t feel like redefining in the new version).</li>
<li>Use Postgres default <strong>security through <a href="http://www.postgresql.org/docs/9.3/static/user-manag.html">roles</a></strong>, not custom app logic. Create the roles and decide which views they can access. Signing into the API should be standard HTTPS auth which forwards to the database for login. Your API will not create its own table with usernames and hashed passwords. If you need to store more info about your users (name, email etc) you can create a table with a foreign key to the <code>pg_authid</code> table.</li>
<li><strong>No controller logic.</strong> Wrap your database behind a <a href="http://sandman.io/">Sandman</a> server. The routes and content of every view is then created mechanically from your database views. If you want to change anything you have to do it in the db. This way there is one source of truth and one place to write tests.</li>
<li>Select the version with proper HTTP <a href="http://blog.begriffs.com/2014/02/api-versioning-best-practices-no-really.html"><strong>content negotiation</strong></a>. The chosen version will determine the schema in which queries execute.</li>
<li>Provide <strong>server-side pagination</strong> through <a href="http://blog.begriffs.com/2014/01/unlocking-deep-http-with-javascript-pt-2.html">headers</a>.</li>
<li><strong>Deploy using Heroku.</strong> I’m not a devops expert, but I know Heroku makes things pretty easy. It handles automated database backup, and has easy Postgres scaling settings (depending on your budget). Add the New Relic <a href="https://newrelic.com/plugins/boundless/109">Postgres Plugin</a>, and autoscale your web dynos with <a href="http://hirefire.io/">HireFire</a>.</li>
</ol>
<p>This is my current opinion about how to create quality APIs. Please help me think through the issues and poke holes in it. Likely both Sandman and depesz/Versioning need more features to support the ideas in my list.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'begriffs';

  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    </div>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <!-- Aww yiss, obsessively watching my numbers! -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-49573102-1', 'begriffs.com');
      ga('send', 'pageview');
    </script>
  </body>
</html>
