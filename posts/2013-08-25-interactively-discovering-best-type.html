<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Interactively discovering the best type classes for Haskell functions</title>
    <link rel="stylesheet" type="text/css" href="../css/bootstrap-readable.min.css" />
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" />
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/syntax.css" />

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  </head>
  <body>
    <div class="container">
      <div class="header row">
        <h3><a class="text-muted col-sm-6" href="../">begriffs</a></h3>

        <ul class="col-sm-6 list-inline">
          <li><a class="text-muted" href="../about.html">About</a></li>
          <li><a class="text-muted" href="http://github.com/begriffs"><i class="fa fa-github"></i></a></li>
          <li><a class="text-muted" href="http://twitter.com/begriffs"><i class="fa fa-twitter"></i></a></li>
        </ul>
      </div>

      <div class="post-header">
  <h3>Interactively discovering the best type classes for Haskell functions</h3>
  <a href="https://twitter.com/share" class="twitter-share-button pull-right" data-via="begriffs" data-count="none">Tweet</a>
  <h5 class="text-muted">August 25, 2013</h5>
</div>

<div class="content">
  <p>Haskell’s type classes exist to make make your functions more general while still keeping you safe. In this post I will work with GHC to arrive at the right signature for a function. The “weaker” the types we choose the more situations a function can handle. It’s instructive to omit types entirely and see how GHC guides us toward the most general thing that can work. I see a parallel between trying to compile in a language like Haskell and running tests in a language like Ruby.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">equal_steps ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
equal_steps x y <span class="fu">=</span> [ (a <span class="fu">-</span> smaller)<span class="fu">/</span>distance <span class="fu">|</span> a <span class="ot">&lt;-</span> [smaller<span class="fu">..</span>larger] ]
  <span class="kw">where</span> smaller  <span class="fu">=</span> min x y
        larger   <span class="fu">=</span> max x y
        distance <span class="fu">=</span> abs (y <span class="fu">-</span> x)</code></pre>
<p>What does this function do, and what inputs are suitable? One way to approach the question is to use duck typing in a dynamic language. Just throw various values in and see if they quack. Write tests to handle a few cases and cross your fingers.</p>
<p>How about asking the compiler which inputs work best? It can examine the type classes it knows and suggest a medley. Let’s try to load this thing in GHC and see what it suggests.</p>
<pre><code>equal_steps.hs:2:34:
    No instance for (Fractional a) arising from a use of `/'
    Possible fix:
      add (Fractional a) to the context of
        the type signature for equal_steps :: a -&gt; a -&gt; [a]
    In the expression: (a - smaller) / distance
    In the expression:
      [(a - smaller) / distance | a &lt;- [smaller .. larger]]
    In an equation for `equal_steps':
        equal_steps x y
          = [(a - smaller) / distance | a &lt;- [smaller .. larger]]
          where
              smaller = min x y
              larger = max x y
              distance = abs (y - x)

equal_steps.hs:2:51:
    No instance for (Enum a)
      arising from the arithmetic sequence `smaller .. larger'
    Possible fix:
      add (Enum a) to the context of
        the type signature for equal_steps :: a -&gt; a -&gt; [a]
    In the expression: [smaller .. larger]
    In a stmt of a list comprehension: a &lt;- [smaller .. larger]
    In the expression:
      [(a - smaller) / distance | a &lt;- [smaller .. larger]]

equal_steps.hs:4:20:
    No instance for (Ord a) arising from a use of `max'
    Possible fix:
      add (Ord a) to the context of
        the type signature for equal_steps :: a -&gt; a -&gt; [a]
    In the expression: max x y
    In an equation for `larger': larger = max x y
    In an equation for `equal_steps':
        equal_steps x y
          = [(a - smaller) / distance | a &lt;- [smaller .. larger]]
          where
              smaller = min x y
              larger = max x y
              distance = abs (y - x)

equal_steps.hs:5:20:
    No instance for (Num a) arising from a use of `abs'
    Possible fix:
      add (Num a) to the context of
        the type signature for equal_steps :: a -&gt; a -&gt; [a]
    In the expression: abs (y - x)
    In an equation for `distance': distance = abs (y - x)
    In an equation for `equal_steps':
        equal_steps x y
          = [(a - smaller) / distance | a &lt;- [smaller .. larger]]
          where
              smaller = min x y
              larger = max x y
              distance = abs (y - x)</code></pre>
<p>It identifies the unknown functions “/”, “..”, “max” and “abs.” What inputs would be appropriate for its arguments? Certainly something numeric. Yeah, we could choose <code>Float -&gt; Float -&gt; [Float]</code>, but we don’t want to be too specific and arbitrary. The language will hold us at our word. If it helps at all to think about the Haskell98 standard options you can examine the handy chart.</p>
<div class="figure">
<img src="../images/typeclasses.gif" alt="Typeclasses" /><p class="caption">Typeclasses</p>
</div>
<p>An arrow pointing from one box to another means that the target box can be used in all the situations that the source can.</p>
<p>Based on the operations we used in our function the compiler suggests restricting the input to being an instance of Fractional, Enum, Ord and Num. This is a powerful way to think about how our function operates. It manipulates a value that can be sensibly divided, enumerated, ordered and acted upon with arithmetic. Let’s add the restriction.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">equal_steps ::</span> (<span class="dt">Fractional</span> a, <span class="dt">Enum</span> a, <span class="dt">Ord</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]
equal_steps x y <span class="fu">=</span> [ (a <span class="fu">-</span> smaller)<span class="fu">/</span>distance <span class="fu">|</span> a <span class="ot">&lt;-</span> [smaller<span class="fu">..</span>larger] ]
  <span class="kw">where</span> smaller  <span class="fu">=</span> min x y
        larger   <span class="fu">=</span> max x y
        distance <span class="fu">=</span> abs (y <span class="fu">-</span> x)</code></pre>
<p>But surely this is redundant! Some of these type classes include the others (in fact we know this is true by consulting the chart above). No need to speculate, just ask GHCi.</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t equal_steps
<span class="ot">equal_steps ::</span> (<span class="dt">Enum</span> a, <span class="dt">Fractional</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</code></pre>
<p>OK, this is simplified a little bit. But you may ask why must we specify both Fractional and Ord? We learned to compare fractions as children. How can this stupid language standard not even consult grade-school math? Well, unlike some languages Haskell was not slapped together in a week in 1995 during a frenzied browser cashlust arms-race to turn a document presentation language into an interactive app platform.</p>
<p>Nope, hearken back to 1927 when Emil Artin defined the concept of an <em>ordered field</em> in mathematics. This is a structure that a Haskeller could think of as Fractional + Ord. Of course the mathematical definition is all about the relationships of the various operations and the Haskell type classes do not enforce those axioms. But it’s the intent of those classes, and Artin produced an example of a field which could not be ordered to suit the axioms: the complex numbers.</p>
<p>In an ordered field the order interacts with the other operations in a way that people find pleasant and fertile with theorems. One property enforced is that if \(a\), \(b &gt; 0\) then \(ab &gt; 0\) too. However in complex numbers the element \(i \neq 0\). The order in an ordered field is <em>total</em> which means that in this case either \(i &gt; 0\) or \(i &lt; 0\). Can’t be the former since \(i^2 = -1 &lt; 0\). And can’t be the latter since \((-i)^2 = -1 &lt; 0\). And that’s a problem.</p>
<p>So there you have it, that’s why the Fractional class doesn’t include the <code>&lt;</code> operator. OK, fine, but why must we specify both Fractional and Enum? Can’t we step through fractions one at a time from lower to higher? Well, depends on the order. In the usual ordering we use for fractions the answer is no. In math terms Enum would be called a well-ordering, because it means there is a single unique successor after each value. However no fraction has a “next” one, You can keep splitting finer and finer between any two fractions. Incidentally there are a few ways to well-order the rational numbers (fractions of integers) if you’re willing to invent a weird order that doesn’t play well with the other arithmetic operations. Georg Cantor discovered one way</p>
<div class="figure">
<img src="../images/diagonal-mapping.jpg" alt="diagonal mapping" /><p class="caption">diagonal mapping</p>
</div>
<p>And that’s why Fractional doesn’t include a range-walking operator. Yeah, it’s like the Haskell98 committee actually put some educated thought into what they were building.</p>
</div>

<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_shortname = 'begriffs';

  (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

    </div>

    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
  </body>
</html>
