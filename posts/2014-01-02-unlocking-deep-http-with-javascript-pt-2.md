---
title: Unlocking Deep HTTP with JavaScript, pt 2
---

{% raw %}
<div class="css-full-post-content js-full-post-content">
<hr /><b>Update</b>: I believe my suggestion for using of Link headers for next, prev, first, last is deprecated. See my article <a href="http://blog.begriffs.com/2014/03/beyond-http-header-links.html">Beyond HTTP Header Links</a>.<br /><hr /><h3></h3>In <a href="http://blog.begriffs.com/2013/12/unlocking-deep-http-with-javascript-pt-1.html" target="_blank">part one</a> I covered some of the history of HTTP and mentioned how my and other people's understanding of the protocol was limited by poor browser implementations. Let's leave all that behind and focus on how web clients and servers can cleanly communicate by taking full advantage of HTTP.<br /><br />Let's focus on server-side pagination, a common part of many apps. It serves as an illustrative case study of how developers perpetuate an early misunderstanding even when it's no longer necessary.<br /><br />The most common way to paginate is to add a query string parameter like <span style="font-family: Courier New, Courier, monospace;">"/stuff?page=2"</span>. This does make sense within imaginary HTML restrictions. A plain HTML link can't say anything except protocol, host, port, url, and query string, so the pagination info gets tacked onto the query string. Note that even if we're sticking with this approach, it's more flexible to use <span style="font-family: Courier New, Courier, monospace;">limit</span> and <span style="font-family: Courier New, Courier, monospace;">offset</span> rather than <span style="font-family: Courier New, Courier, monospace;">page</span>. This way the client can request any contiguous range of results.<br /><br />But how does the client know when to send those parameters? Presumably because the authors of the client code wrote the backend too and just know. The ends are coupled with secret information. Think about the alternative, what if pagination could be discovered and negotiated? This problem is not novel and not restricted to the pagination that users see. It's essentially the same problem as downloading a large file in parts, and selectively requesting any part (to resume a download, for instance).<br /><br />Happily this feature was introduced in RFC<span style="white-space: pre-wrap;">2616 in the 90s. </span>The client can use it to discover when a collection supports pagination and then automatically add an appropriate interface for the user. That way the client code can then use uniform list rendering code and can gracefully degrade to non-paginated information.<br /><br />Here's the trick. If we think of paginated API collections like big downloads we can use HTTP headers to discover if pagination is required and to restrict responses. In particular we can use the&nbsp;<span style="font-family: Courier New, Courier, monospace;">Range</span>&nbsp;request header. Here's an example network exchange to demonstrate how this works.<br /><br /><b>Client</b>: HEAD /biglist<br /><b>Server</b>:&nbsp;Accept-Ranges → items<br /><br />In its response headers the server says it accepts the <span style="font-family: Courier New, Courier, monospace;">Range</span> restriction where the <span style="font-family: Courier New, Courier, monospace;">Range-Unit</span> is expressed as "items." For traditional file-downloading the unit is bytes, but the spec allows custom units. What if the client disregards the hint?<br /><br /><b>Client</b>: GET /biglist<br /><b>Server</b>: Status&nbsp;→ 413 Request Entity Too Large<br /><br />This is one option. If the response is just too large and would be burdensome the server can refuse in a standard way. This means a range is required. Alternately the server could send the whole list with status 200 OK.<br /><br />When the client requests a range there are three possible responses.<br /><br /><b>Client</b>: GET /biglist; Range-Unit: items; Range: 0-99<br /><b>Server</b>: Status → 206; Content-Range: 0-99/1234<br /><br />This is a successful result (a 2xx code) for partial content delivery. It confirms the range delivered and includes the total number of items (1234) or * if the total is unknown, hard to calculate, or infinite. The other possible responses are status 416 for incomprehensible range or those that go outside the available data, and status 413 if the range is still too large to handle.<br /><br />By putting metadata -- such as the total number of items -- in the head, we can clean up the actual data returned by an API. Putting the metadata in the JSON payload clutters the result. This is awkward:<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8215892"></code>It would be much nicer to get a straight array of the data as the whole response. But once the client parses this JSON, it will need to store the metadata, so how do we keep the data pure and clean? In JavaScript the answer is non-enumerable properties. I'd argue that these properties correspond roughly to HTTP headers. They won't clutter the results of looping through a result-set, but they are there if you ask for them directly.<br /><br /><code data-gist-hide-footer="true" data-gist-hide-line-numbers="true" data-gist-id="8215933"></code>Notice the loop was unaffected by the <span style="font-family: Courier New, Courier, monospace;">total_items</span> metadata. Hence I imagine client code will send HTTP requests for paginated data, parse the headers and record the range discreetly using <span style="font-family: Courier New, Courier, monospace;">defineProperty()</span>.<br /><br />Finally, how should we calculate or communicate links for the first, last, next, and previous pages? The HATEOAS constraint of RESTful design says that this information should be provided by the server as hypermedia affordances. Not to worry, headers to the rescue again. RFC5988 describes link headers which point to other URLs and describe their relation to the current document. So the server can include<br /><br /><b>Server</b>: Link → &lt;/biglist&gt;; rel="next"<br /><br />But there's one problem, where is the range? It's no longer a query string, so it can't be specified within the angle brackets. The answer is to use a link-extension parameter. We can include a parameter for the client code can interpret appropriately.<br /><br /><b>Server</b>: Link → &lt;/biglist&gt;; rel="next"; items="100-199"<br /><br />This concludes the overview of digging into HTTP to solve a common feature of web apps.
</div>
{% endraw %}
